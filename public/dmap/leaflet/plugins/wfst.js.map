{"version":3,"sources":["webpack:///plugins/wfst.js","webpack:///webpack/bootstrap 7b19f38a437100774b0e","webpack:///./node_modules/leaflet-wfst/dist/leaflet-wfst.src.js"],"names":["define","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","181","window","document","undefined","L","XmlUtil","namespaces","xlink","xmlns","xsd","xsi","wfs","gml","ogc","ows","xmldoc","DOMParser","parseFromString","setAttributes","node","attributes","toString","value","uri","this","substring","indexOf","setAttributeNS","evaluate","xpath","xml","xmlDoc","Document","parseXml","xpe","XPathEvaluator","nsResolver","createNSResolver","documentElement","XPathResult","ANY_TYPE","createElementNS","options","prefix","createElement","appendChild","createTextNode","Date","toISOString","getNodeText","innerText","textContent","text","serializeXmlDocumentString","doc","implementation","createDocument","XMLSerializer","serializeToString","serializeXmlToString","rawXml","ActiveXObject","async","loadXML","Error","parseOwsExceptionReport","exceptionReportElement","tagName","exceptionReport","exceptions","message","exceptionsNodes","getElementsByTagNameNS","exceptionsNodesCount","length","exceptionNode","exceptionCode","getAttribute","exceptionsTextNodes","exception","code","j","textNodesCount","exceptionTextNode","exceptionText","push","Util","request","extend","method","data","params","headers","url","location","href","withCredentials","success","console","log","error","complete","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","getParamString","open","header","setRequestHeader","send","Filter","filter","filters","result","Array","isArray","forEach","element","Element","toGml","propertyName","literal","propertyElement","literalElement","Abstract","Class","buildFilterContent","filterElement","BinarySpatial","initialize","crs","Equals","equals","Disjoint","disjoint","Touches","touches","Within","within","Overlaps","overlaps","Crosses","crosses","Intersects","intersects","Contains","contains","DistanceBuffer","geometry","distance","units","geomerty","DWithin","dwithin","Beyond","beyond","BBox","geometryField","bbox","GmlObjectID","id","gml:id","gmlobjectid","BinaryOperator","firstValue","secondValue","Add","add","a","b","Sub","sub","Mul","mul","Div","div","BinaryComparison","matchCase","EQ","eq","NotEQ","neq","LT","lt","GT","gt","LEQ","leq","GEQ","geq","Like","wildCard","singleChar","escapeChar","val","defaultAttributes","nameElement","valueElement","like","IsNull","isnull","IsBetween","lowerBoundary","upperBoundary","lowerBoundaryElement","upperBoundaryElement","isbetween","BinaryLogic","arguments","And","and","Function","bind","apply","Or","or","Not","not","functionName","expressions","firstArgument","functionArgument","function","Format","Scheme","setOptions","parse","featureType","GML","FeatureType","complexTypeDefinition","properties","children","typeAttr","type","base","typeName","split","pop","appendField","geometryFields","Base","defaultOptions","CRS","EPSG3857","coordsToLatLng","coords","LatLng","latLngToCoords","latlng","lng","lat","alt","point","ll","projection","unproject","latLng","project","setFeatureDescription","featureInfo","namespaceUri","targetNamespace","schemeParser","responseToLayers","GeoJSON","outputFormat","rawData","layers","geoJson","JSON","features","layer","processFeature","feature","generateLayer","geometryToLayer","ParserContainerMixin","parsers","initializeParserContainer","appendParser","parser","elementTag","parseElement","Geometry","elementOptions","dimension","parseInt","Coordinates","defaultSeparator","ds","cs","ts","decimal","mapFunction","coord","replace","parseFloat","map","Pos","PosList","statics","DIM","dim","PointNode","includes","firstElementChild","PointSequence","firstChild","childParser","elements","LinearRing","LineStringNode","PolygonNode","linearRingParser","child","CoordsToLatLngMixin","transform","coordinates","latLngs","Point","Marker","setLatLng","LineString","Polyline","setLatLngs","Polygon","MultiGeometry","childObjects","geometryMember","singleGeometry","AbstractMultiPolyline","AbstractMultiPolygon","MultiLineString","MultiCurve","MultiPolygon","MultiSurface","MultiPoint","multiPoint","FeatureGroup","addLayer","primitives","types","input","String","trim","Number","validate","parsedValue","isNaN","toLowerCase","fields","fieldValidators","fieldTypes","that","primitive","parseField","featureCollection","featureMemberNodes","featureAsLayer","featureMembersNode","nodeAsLayer","innerHTML","latlngs","isFlat","LineUtil","_flat","GmlUtil","posNode","srsDimension","x","y","posListNode","close","localcoords","posList","join","CircleMarker","include","srsName","getLatLng","LatLngBounds","projectedSW","getSouthWest","projectedNE","getNorthEast","envelopeElement","forceMulti","polygons","getLatLngs","gmlPolygons","polygonCoordinates","flat","hole","multi","collection","_lineStringNode","gmlElements","lines","PropertiesMixin","setProperties","obj","getProperty","field","deleteProperties","arr","Path","WFS","_capabilities","_boundingBox","showExisting","version","typeNS","typeNSName","maxFeatures","opacity","fillOpacity","style","color","weight","state","readFormat","exist","_layers","namespaceName","_updateOpacity","describeFeatureType","loadFeatures","errorMessage","fire","successCallback","errorCallback","requestData","service","getFeature","query","pointToLayer","setStyle","getCapabilities","capabilities","getBoundingBox","boundingBox","featureTypeListElement","getElementsByTagName","featureTypeList","len","wgs84BoundingBox","lowerCornerElement","upperCornerElement","lowerCorner","upperCorner","sw","reverse","ne","latLngBounds","setOpacity","WFST","insert","update","remove","changes","getLayerId","removeLayer","change","editLayer","save","transaction","inserted","action","insertResult","insertedIds","iterateNext","once","wfst","gmlFeature","featureNode","gmlProperty","propertyNode","xsi:nil","wfsProperty","valueNode","insertElement","updateElement","idFilter","removeElement"],"mappings":"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","file":"plugins/wfst.js","sourcesContent":["/*! version:1.4.13 */\ndefine(function() { return /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./dist/dmap/leaflet/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 181);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 181:\n/***/ (function(module, exports) {\n\n/*! leaflet-wfst 2.0.1-beta.21 2018-05-11 */\n(function(window, document, undefined) {\n\n\"use strict\";\n\nL.XmlUtil = {\n  namespaces: {\n    xlink: 'http://www.w3.org/1999/xlink',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xsd: 'http://www.w3.org/2001/XMLSchema',\n    xsi: 'http://www.w3.org/2001/XMLSchema-instance',\n    wfs: 'http://www.opengis.net/wfs',\n    gml: 'http://www.opengis.net/gml',\n    ogc: 'http://www.opengis.net/ogc',\n    ows: 'http://www.opengis.net/ows'\n  },\n\n  // TODO: find another way to create a new document with doctype text/xml?\n  xmldoc: (new DOMParser()).parseFromString('<root />', 'text/xml'),\n\n  setAttributes: function (node, attributes) {\n    for (var name in attributes) {\n      if (attributes[name] != null && attributes[name].toString) {\n        var value = attributes[name].toString();\n        var uri = this.namespaces[name.substring(0, name.indexOf(':'))] || null;\n        node.setAttributeNS(uri, name, value);\n      }\n    }\n  },\n\n  evaluate: function (xpath, xml) {\n    var xmlDoc = xml;\n    if (!(xmlDoc instanceof Document)) {\n      xmlDoc = this.parseXml(xml);\n    }\n\n    var xpe = new XPathEvaluator();\n    var nsResolver = xpe.createNSResolver(xmlDoc.documentElement);\n\n    return xpe.evaluate(xpath, xmlDoc, nsResolver, XPathResult.ANY_TYPE, null);\n  },\n\n  createElementNS: function (name, attributes, options) {\n    options = options || {};\n\n    var uri = options.uri;\n\n    if (!uri) {\n      uri = this.namespaces[name.substring(0, name.indexOf(':'))];\n    }\n\n    if (!uri) {\n      uri = this.namespaces[options.prefix];\n    }\n\n    var node = uri ? this.xmldoc.createElementNS(uri, name) : this.xmldoc.createElement(name);\n\n    if (attributes) {\n      this.setAttributes(node, attributes);\n    }\n\n    if (options.value != null) {\n      node.appendChild(this.xmldoc.createTextNode(options.value));\n    }\n\n    return node;\n  },\n\n  createTextNode: function (value) {\n    if(value === null || value === undefined) {\n      value = '';\n    } else if(value instanceof Date) {\n      value = value.toISOString();\n    }\n\n    return this.xmldoc.createTextNode(value);\n  },\n\n  getNodeText: function (node) {\n    if (!node) {\n      return '';\n    }\n\n    return node.innerText || node.textContent || node.text;\n  },\n\n  serializeXmlDocumentString: function (node) {\n    var doc = document.implementation.createDocument('', '', null);\n    doc.appendChild(node);\n    var serializer = new XMLSerializer();\n    return serializer.serializeToString(doc);\n  },\n\n  serializeXmlToString: function (node) {\n    var serializer = new XMLSerializer();\n    return serializer.serializeToString(node);\n  },\n\n  parseXml: function (rawXml) {\n    if (typeof window.DOMParser !== 'undefined') {\n      return (new window.DOMParser()).parseFromString(rawXml, 'text/xml');\n    } else if (typeof window.ActiveXObject !== 'undefined' && new window.ActiveXObject('Microsoft.XMLDOM')) {\n      var xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');\n      xmlDoc.async = 'false';\n      xmlDoc.loadXML(rawXml);\n      return xmlDoc;\n    } else {\n      throw new Error('No XML parser found');\n    }\n  },\n\n  parseOwsExceptionReport: function (xml) {\n    var xmlDoc = xml;\n    if (!(xmlDoc instanceof Document)) {\n      xmlDoc = this.parseXml(xml);\n    }\n\n    var exceptionReportElement = xmlDoc.documentElement;\n    if (!exceptionReportElement || exceptionReportElement.tagName !== 'ows:ExceptionReport') {\n      return null;\n    }\n\n    var exceptionReport = {\n      exceptions: [],\n      message: ''\n    };\n\n    var exceptionsNodes = exceptionReportElement.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'Exception');\n    for (var i = 0, exceptionsNodesCount = exceptionsNodes.length; i < exceptionsNodesCount; i++) {\n      var exceptionNode = exceptionsNodes[i];\n      var exceptionCode = exceptionNode.getAttribute('exceptionCode');\n      var exceptionsTextNodes = exceptionNode.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'ExceptionText');\n      var exception = {\n        code: exceptionCode,\n        text: ''\n      };\n\n      for (var j = 0, textNodesCount = exceptionsTextNodes.length; j < textNodesCount; j++) {\n        var exceptionTextNode = exceptionsTextNodes[j];\n        var exceptionText = exceptionTextNode.innerText || exceptionTextNode.textContent || exceptionTextNode.text;\n\n        exception.text += exceptionText;\n        if (j < textNodesCount - 1) {\n          exception.text += '. ';\n        }\n      }\n\n      exceptionReport.message += exception.code + ' - ' + exception.text;\n      if (i < exceptionsNodesCount - 1) {\n        exceptionReport.message += ' ';\n      }\n\n      exceptionReport.exceptions.push(exception);\n    }\n\n    return exceptionReport;\n  }\n};\n\nL.Util.request = function (options) {\n  options = L.extend({\n    async: true,\n    method: 'POST',\n    data: '',\n    params: {},\n    headers: {},\n    url: window.location.href,\n    withCredentials: false,\n    success: function (data) {\n      console.log(data);\n    },\n    error: function (data) {\n      console.log('Ajax request fail');\n      console.log(data);\n    },\n    complete: function () {\n    }\n  }, options);\n\n  // good bye IE 6,7\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        options.success(xhr.responseText);\n      } else {\n        options.error(xhr.responseText);\n      }\n      options.complete();\n    }\n  };\n  xhr.withCredentials = options.withCredentials;\n\n  var url = options.url + L.Util.getParamString(options.params, options.url);\n\n  xhr.open(options.method, url, options.async);\n  for (var header in options.headers) {\n    xhr.setRequestHeader(header, options.headers[header]);\n  }\n\n  xhr.send(options.data);\n};\n\nL.Filter = {};\n\nL.filter = function (filters) {\n  var result = L.XmlUtil.createElementNS('ogc:Filter');\n\n  if (Array.isArray(filters)) {\n    filters.forEach(function (element) {\n      result.appendChild(element instanceof Element ? element : element.toGml());\n    });\n  } else if (filters) {\n    result.appendChild(filters instanceof Element ? filters : filters.toGml());\n  }\n\n  return result;\n};\n\nL.Filter.propertyName = function (value) {\n  return L.XmlUtil.createElementNS('ogc:PropertyName', {}, { value: value });\n};\n\nL.Filter.literal = function (value) {\n  return L.XmlUtil.createElementNS('ogc:Literal', {}, { value: value });\n};\n\nL.Filter.element = function(value) {\n  if(value instanceof Element) {\n    return value;\n  }\n\n  return value.toGml();\n};\n\nL.Filter.propertyElement = function (value) {\n  if (value instanceof Element) {\n    return value;\n  }\n\n  if (value && typeof (value.toGml) === \"function\") {\n    return value.toGml();\n  }\n\n  return L.Filter.propertyName(value);\n};\n\nL.Filter.literalElement = function (value) {\n  if (value instanceof Element) {\n    return value;\n  }\n\n  if (value && typeof (value.toGml) === \"function\") {\n    return value.toGml();\n  }\n\n  return L.Filter.literal(value);\n};\n\nL.Filter.Abstract = L.Class.extend({\n  attributes: {},\n\n  options: {},\n\n  tagName: null,\n\n  buildFilterContent: function() {\n    throw \"Build filter content is abstract and should be implemented\";\n  },\n\n  toGml: function() {\n    var filterElement = L.XmlUtil.createElementNS(this.tagName, this.attributes, this.options);\n    this.buildFilterContent(filterElement);\n    return filterElement;\n  }\n});\n\nL.Filter.BinarySpatial = L.Filter.Abstract.extend({\n  initialize: function (propertyName, value, crs) {\n    this.propertyName = propertyName;\n    this.value = value;\n    this.crs = crs;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyName(this.propertyName));\n    if (typeof(this.value) === \"string\") {\n      filterElement.appendChild(L.Filter.propertyName(this.value));\n    } else {\n      filterElement.appendChild(this.value.toGml(this.crs));\n    }\n    return filterElement;\n  }\n});\n\nL.Filter.Equals = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Equals'\n});\n\nL.Filter.equals = function(options) {\n  return new L.Filter.Equals(options);\n};\n\nL.Filter.Disjoint = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Disjoint'\n});\n\nL.Filter.disjoint = function(options) {\n  return new L.Filter.Disjoint(options);\n};\n\nL.Filter.Touches = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Touches'\n});\n\nL.Filter.touches = function(options) {\n  return new L.Filter.Touches(options);\n};\n\nL.Filter.Within = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Within'\n});\n\nL.Filter.within = function(options) {\n  return new L.Filter.Within(options);\n};\n\nL.Filter.Overlaps = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Overlaps'\n});\n\nL.Filter.overlaps = function(options) {\n  return new L.Filter.Overlaps(options);\n};\n\nL.Filter.Crosses = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Crosses'\n});\n\nL.Filter.crosses = function(options) {\n  return new L.Filter.Crosses(options);\n};\n\nL.Filter.Intersects = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Intersects'\n});\n\nL.Filter.intersects = function(options) {\n  return new L.Filter.Intersects(options);\n};\n\nL.Filter.Contains = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Contains'\n});\n\nL.Filter.contains = function(options) {\n  return new L.Filter.Contains(options);\n};\n\nL.Filter.DistanceBuffer = L.Filter.Abstract.extend({\n  initialize: function (propertyName, geometry, crs, distance, units) {\n    this.propertyName = propertyName;\n    this.geomerty = geometry;\n    this.crs = crs;\n    this.distance = distance;\n    this.units = units;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyName(this.propertyName));\n    filterElement.appendChild(this.geomerty.toGml(this.crs));\n    filterElement.appendChild(L.XmlUtil.createElementNS('ogc:Distance', { 'units': this.units }, { value: this.distance }));\n  }\n});\n\nL.Filter.DWithin = L.Filter.DistanceBuffer.extend({\n  tagName: 'ogc:DWithin'\n});\n\nL.Filter.dwithin = function(propertyName, geometry, crs, distance, units) {\n  return new L.Filter.DWithin(propertyName, geometry, crs, distance, units);\n};\n\nL.Filter.Beyond = L.Filter.DistanceBuffer.extend({\n  tagName: 'ogc:Beyond'\n});\n\nL.Filter.beyond = function(propertyName, geometry, crs, distance, units) {\n  return new L.Filter.Beyond(propertyName, geometry, crs, distance, units);\n};\n\nL.Filter.BBox = L.Filter.Abstract.extend({\n  tagName: 'ogc:BBOX',\n\n  geometryField: null,\n\n  bbox: null,\n\n  crs: null,\n\n  initialize: function (geometryField, bbox, crs) {\n    this.bbox = bbox;\n    this.geometryField = geometryField;\n    this.crs = crs;\n  },\n\n  buildFilterContent: function (filterElement) {\n    if (this.geometryField) {\n      filterElement.appendChild(L.Filter.propertyName(this.geometryField));\n    }\n\n    filterElement.appendChild(this.bbox.toGml(this.crs));\n  }\n});\n\nL.Filter.bbox = function (geometryField, bbox, crs) {\n  return new L.Filter.BBox(geometryField, bbox, crs);\n};\n\nL.Filter.GmlObjectID = L.Filter.Abstract.extend({\n  tagName: 'ogc:GmlObjectId',\n\n  initialize: function (id) {\n    this.attributes =  { 'gml:id': id };\n  },\n\n  buildFilterContent: function() {\n  }\n});\n\nL.Filter.gmlobjectid = function(id) {\n  return new L.Filter.GmlObjectID(id);\n};\n\nL.Filter.BinaryOperator = L.Filter.Abstract.extend({\n  initialize: function (firstValue, secondValue) {\n    this.firstValue = firstValue;\n    this.secondValue = secondValue;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyElement(this.firstValue));\n    filterElement.appendChild(L.Filter.literalElement(this.secondValue));\n  }\n});\n\nL.Filter.Add = L.Filter.BinaryOperator.extend({\n  tagName: 'Add'\n});\n\nL.Filter.add = function(a, b) {\n  return new L.Filter.Add(a, b);\n};\n\nL.Filter.Sub = L.Filter.BinaryOperator.extend({\n  tagName: 'Sub'\n});\n\nL.Filter.sub = function(a, b) {\n  return new L.Filter.Sub(a, b);\n};\n\nL.Filter.Mul = L.Filter.BinaryOperator.extend({\n  tagName: 'Mul'\n});\n\nL.Filter.mul = function(a, b) {\n  return new L.Filter.Mul(a, b);\n};\n\nL.Filter.Div = L.Filter.BinaryOperator.extend({\n  tagName: 'Div'\n});\n\nL.Filter.div = function(a, b) {\n  return new L.Filter.Div(a, b);\n};\n\nL.Filter.BinaryComparison = L.Filter.BinaryOperator.extend({\n  matchCase: false,\n\n  initialize: function(firstValue, secondValue, matchCase) {\n    L.Filter.BinaryOperator.prototype.initialize.call(this, firstValue, secondValue);\n    this.attributes = { matchCase: !!matchCase };\n  }\n});\n\nL.Filter.EQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsEqualTo'\n});\n\nL.Filter.eq = function(firstValue, secondValue) {\n  return new L.Filter.EQ(firstValue, secondValue);\n};\n\nL.Filter.NotEQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsNotEqualTo'\n});\n\nL.Filter.neq = function(firstValue, secondValue) {\n  return new L.Filter.NotEQ(firstValue, secondValue);\n};\n\nL.Filter.LT = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsLessThan'\n});\n\nL.Filter.lt = function(firstValue, secondValue) {\n  return new L.Filter.LT(firstValue, secondValue);\n};\n\nL.Filter.GT = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsGreaterThan'\n});\n\nL.Filter.gt = function(firstValue, secondValue) {\n  return new L.Filter.GT(firstValue, secondValue);\n};\n\nL.Filter.LEQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsLessThanOrEqualTo'\n});\n\nL.Filter.leq = function(firstValue, secondValue) {\n  return new L.Filter.LEQ(firstValue, secondValue);\n};\n\nL.Filter.GEQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsGreaterThanOrEqualTo'\n});\n\nL.Filter.geq = function(firstValue, secondValue) {\n  return new L.Filter.GEQ(firstValue, secondValue);\n};\n\nL.Filter.Like = L.Filter.Abstract.extend({\n  tagName: 'ogc:PropertyIsLike',\n\n  wildCard: '*',\n  singleChar: '#',\n  escapeChar: '!',\n  matchCase: true,\n\n  initialize: function (name, val, attributes) {\n    this.name = name;\n    this.val = val;\n    var defaultAttributes = { wildCard: this.wildCard, singleChar: this.singleChar, escapeChar: this.escapeChar, matchCase: this.matchCase };\n    this.attributes = L.extend(defaultAttributes, attributes || {});\n  },\n\n  buildFilterContent: function (filterElement) {\n    var nameElement = L.Filter.propertyName(this.name);\n    var valueElement = L.Filter.literal(this.val);\n    filterElement.appendChild(nameElement);\n    filterElement.appendChild(valueElement);\n    return filterElement;\n  }\n});\n\nL.Filter.like = function(name, val, attributes) {\n  return new L.Filter.Like(name, val, attributes);\n};\n\nL.Filter.IsNull = L.Filter.Abstract.extend({\n  tagName: 'ogc:PropertyIsNull',\n\n  initialize: function (propertyName) {\n    this.propertyName = propertyName;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyName(this.propertyName));\n  }\n});\n\nL.Filter.isnull = function(propertyName) {\n  return new L.Filter.IsNull(propertyName);\n};\n\nL.Filter.IsBetween = L.Filter.Abstract.extend({\n  tagName: 'ogc:PropertyIsBetween',\n\n  initialize: function (property, lowerBoundary, upperBoundary) {\n    this.property = property;\n    this.lowerBoundary = lowerBoundary;\n    this.upperBoundary = upperBoundary;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyElement(this.property));\n\n    var lowerBoundaryElement = L.XmlUtil.createElementNS('ogc:LowerBoundary');\n    lowerBoundaryElement.appendChild(L.Filter.literalElement(this.lowerBoundary));\n\n    filterElement.appendChild(lowerBoundaryElement);\n\n    var upperBoundaryElement = L.XmlUtil.createElementNS('ogc:UpperBoundary');\n    upperBoundaryElement.appendChild(L.Filter.literalElement(this.upperBoundary));\n\n    filterElement.appendChild(upperBoundaryElement);\n  }\n});\n\nL.Filter.isbetween = function(property, lowerBoundary, upperBoundary) {\n  return new L.Filter.IsBetween(property, lowerBoundary, upperBoundary);\n};\n\nL.Filter.BinaryLogic = L.Filter.Abstract.extend({\n  filters: null,\n\n  initialize: function () {\n    var filters = [];\n    for (var i = 0; i < arguments.length; i++) {\n      filters.push(arguments[i]);\n    }\n\n    this.filters = filters;\n  },\n\n  buildFilterContent: function (filterElement) {\n    this.filters.forEach(function(filter) {\n      filterElement.appendChild(L.Filter.element(filter));\n    });\n  }\n});\n\nL.Filter.And = L.Filter.BinaryLogic.extend({\n  tagName: 'And'\n});\n\nL.Filter.and = function() {\n  return new (Function.prototype.bind.apply(L.Filter.And, arguments))();\n};\n\nL.Filter.Or = L.Filter.BinaryLogic.extend({\n  tagName: 'Or'\n});\n\nL.Filter.or = function() {\n  return new (Function.prototype.bind.apply(L.Filter.Or, arguments))();\n};\n\nL.Filter.Not = L.Filter.Abstract.extend({\n  tagName: 'Not',\n\n  initialize: function(filter) {\n    this.filter = filter;\n  },\n\n  buildFilterContent: function(filterElement) {\n    filterElement.appendChild(L.Filter.element(this.filter));\n  }\n});\n\nL.Filter.not = function(filter) {\n  return new L.Filter.Not(filter);\n};\n\nL.Filter.Function = L.Filter.Abstract.extend({\n  tagName: 'Function',\n\n  initialize: function () {\n    var functionName = arguments[0];\n    this.attributes = { name: functionName };\n    var expressions = [];\n    for (var i = 1; i < arguments.length; i++) {\n      expressions.push(arguments[i]);\n    }\n\n    this.expressions = expressions;\n  },\n\n  buildFilterContent: function (filterElement) {\n    var firstArgument = this.expressions[0];\n    filterElement.appendChild(L.Filter.propertyElement(firstArgument));\n\n    for (var i = 1; i < this.expressions.length; i++) {\n      var functionArgument = this.expressions[i];\n      filterElement.appendChild(L.Filter.literalElement(functionArgument));\n    }\n  }\n});\n\nL.Filter.function = function() {\n  return new (Function.prototype.bind.apply(L.Filter.Function, arguments))();\n};\n\nL.Format = {};\n\nL.Format.Scheme = L.Class.extend({\n  options: {\n    geometryField: 'Shape',\n  },\n\n  initialize: function (options) {\n    L.setOptions(this, options);\n  },\n\n  parse: function (element) {\n    var featureType = new L.GML.FeatureType({\n      geometryField: this.options.geometryField\n    });\n    var complexTypeDefinition = element.getElementsByTagNameNS(L.XmlUtil.namespaces.xsd, 'complexType')[0];\n    var properties = complexTypeDefinition.getElementsByTagNameNS(L.XmlUtil.namespaces.xsd, 'sequence')[0];\n    for (var i = 0; i < properties.children.length; i++) {\n      var node = properties.children[i];\n      var propertyAttr = node.attributes.name;\n      if (!propertyAttr) {\n        continue;\n      }\n\n      var propertyName = node.attributes.name.value;\n      var typeAttr = node.attributes.type;\n      if (!typeAttr) {\n        var restriction = node.getElementsByTagNameNS(L.XmlUtil.namespaces.xsd, 'restriction');\n        typeAttr = restriction.attributes.base;\n      }\n\n      if (!typeAttr) {\n        continue;\n      }\n\n      var typeName = typeAttr.value.split(':').pop();\n\n      if (propertyName === this.options.geometryField) {\n        featureType.geometryFields[propertyName] = typeName;\n        continue;\n      }\n\n      featureType.appendField(propertyName, typeName);\n    }\n\n    return featureType;\n  }\n});\n\nL.Format.Base = L.Class.extend({\n\n  /**\n   * @property defaultOptions\n   */\n  defaultOptions: {\n    crs: L.CRS.EPSG3857,\n    coordsToLatLng: function (coords) {\n      return new L.LatLng(coords[1], coords[0], coords[2]);\n    },\n    latLngToCoords: function (latlng) {\n      var coords = [latlng.lng, latlng.lat];\n      if (latlng.alt !== undefined) {\n        coords.push(latlng.alt);\n      }\n      return coords;\n    },\n    geometryField: 'Shape'\n  },\n\n  initialize: function (options) {\n    L.setOptions(this, L.extend({}, this.defaultOptions, options));\n    if (options.crs) {\n      var crs = options.crs;\n      this.options.coordsToLatLng = function (coords) {\n        var point = L.point(coords[0], coords[1]);\n        var ll = crs.projection.unproject(point);\n        if (coords[2]) {\n          ll.alt = coords[2];\n        }\n        return ll;\n      };\n      this.options.latLngToCoords = function (ll) {\n        var latLng = L.latLng(ll);\n        return crs.projection.project(latLng);\n      };\n    }\n  },\n\n  /**\n   * Generate feature description by response from DescribeFeatureType\n   *\n   * @method setFeatureDescription\n   * @param {Element} featureInfo response from WFS DescribeFeatureType request\n   */\n  setFeatureDescription: function (featureInfo) {\n    this.namespaceUri = featureInfo.attributes.targetNamespace.value;\n    var schemeParser = new L.Format.Scheme({\n      geometryField: this.options.geometryField\n    });\n    this.featureType = schemeParser.parse(featureInfo);\n  },\n\n  responseToLayers: function() {\n    throw \"responseToLayers is abstract and should be implemented\";\n  }\n});\n\nL.Format.GeoJSON = L.Format.Base.extend({\n\n  outputFormat: 'application/json',\n\n  /**\n   * Convert raw data to leaflet layers array\n   *\n   * @method responseToLayers\n   * @param {string} rawData\n   * @return {Array} Array of leaflet layers\n   */\n  responseToLayers: function (rawData) {\n    var layers = [];\n    var geoJson = JSON.parse(rawData);\n\n    for (var i = 0; i < geoJson.features.length; i++) {\n      var layer = this.processFeature(geoJson.features[i]);\n      if (layer) {\n        layers.push(layer);\n      }\n    }\n\n    return layers;\n  },\n\n  /**\n   * Create layer and set its properties from geoJson feature\n   *\n   * @method processFeature\n   * @param {json} feature\n   * @return {Layer} leaflet layer with \"feature\" property with feature fields values\n   * @private\n   */\n  processFeature: function (feature) {\n    var layer = this.generateLayer(feature);\n    if (!layer) {\n      return null;\n    }\n\n    layer.feature = feature;\n    return layer;\n  },\n\n  /**\n   * Create leaflet layer from geoJson feature\n   *\n   * @method generateLayer\n   * @param {json} feature\n   * @return {Layer} leaflet layer\n   * @private\n   */\n  generateLayer: function (feature) {\n    var layer = L.GeoJSON.geometryToLayer(feature, this.options || null);\n    if (!layer) {\n      console.log(\n        'Geometry field doesn\\' exist inside received feature: \\'' + feature + '\\', ' +\n        'so feature will be skipped and won\\'t be converted into leaflet layer');\n\n        return null;\n    }\n\n    return layer;\n  }\n});\n\nL.GML = L.GML || {};\n\nL.GML.ParserContainerMixin = {\n\n  parsers: {},\n\n  initializeParserContainer: function () {\n    this.parsers = {};\n  },\n\n  appendParser: function (parser) {\n    this.parsers[parser.elementTag] = parser;\n  },\n\n  parseElement: function (element, options) {\n    var parser = this.parsers[element.tagName];\n    if (!parser) throw('unknown child element ' + element.tagName);\n\n    return parser.parse(element, options);\n  }\n};\n\nL.GML.Element = L.Class.extend({\n  elementTag: '',\n  parse: function () {\n    throw('not implemented parse function in parser for ' + this.elementTag);\n  }\n});\n\nL.GML.Geometry = L.GML.Element.extend({\n\n  /**\n   * Returns new object where options properties merged with element specific values\n   *\n   * @method elementOptions\n   * @param {Element} element\n   * @param {Object} options\n   */\n  elementOptions: function(element, options) {\n    var result = L.extend({}, options);\n    var dimension = element.getAttribute('srsDimension');\n    if(dimension) {\n      result.dimension = parseInt(dimension);\n    }\n\n    return result;\n  }\n});\n\nL.GML.Coordinates = L.GML.Element.extend({\n\n  defaultSeparator: {\n    ds: '.', //decimal separator\n    cs: ',', // component separator\n    ts: ' ' // tuple separator\n  },\n\n  elementTag: 'gml:coordinates',\n\n  parse: function (element) {\n\n    var ds = this.defaultSeparator.ds;\n    if (element.attributes.decimal) {\n      ds = element.attributes.decimal.value;\n    }\n\n    var cs = this.defaultSeparator.cs;\n    if (element.attributes.cs) {\n      cs = element.attributes.cs.value;\n    }\n\n    var ts = this.defaultSeparator.ts;\n    if (element.attributes.ts) {\n      ts = element.attributes.ts.value;\n    }\n\n    var result = [];\n    var coords = element.textContent.split(ts);\n\n    var mapFunction = function (coord) {\n      if (ds !== '.') {\n        coord = coord.replace(ds, '.');\n      }\n\n      return parseFloat(coord);\n    };\n\n    for (var i = 0; i < coords.length; i++) {\n      result.push(coords[i].split(cs).map(mapFunction));\n    }\n\n    if (result.length === 1) {\n      return result[0];\n    }\n\n    return result;\n  }\n});\n\nL.GML.Pos = L.GML.Element.extend({\n\n  elementTag: 'gml:pos',\n\n  parse: function (element) {\n    return element.textContent.split(' ').map(function (coord) {\n      return parseFloat(coord);\n    });\n  }\n});\n\nL.GML.PosList = L.GML.Element.extend({\n  statics: {\n    DIM: 2\n  },\n\n  elementTag: 'gml:posList',\n\n  parse: function (element, options) {\n    var result = [];\n    options = options || {};\n    var dim = options.dimension || L.GML.PosList.DIM;\n    var coords = element.textContent.split(' ');\n    for (var i = 0; i < coords.length; i += dim) {\n      var coord = [];\n      for (var j = i; j < i + dim; j++) {\n        coord.push(parseFloat(coords[j]));\n      }\n      result.push(coord);\n    }\n\n    return result;\n  }\n});\n\nL.GML.PointNode = L.GML.Geometry.extend({\n  includes: L.GML.ParserContainerMixin,\n\n  elementTag: 'gml:Point',\n\n  initialize: function () {\n    this.initializeParserContainer();\n    this.appendParser(new L.GML.Pos());\n    this.appendParser(new L.GML.Coordinates());\n  },\n\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    return this.parseElement(element.firstElementChild, options);\n  }\n});\n\nL.GML.PointSequence = L.GML.Geometry.extend({\n  includes: L.GML.ParserContainerMixin,\n\n  initialize: function () {\n    this.initializeParserContainer();\n    this.appendParser(new L.GML.Pos());\n    this.appendParser(new L.GML.PosList());\n    this.appendParser(new L.GML.Coordinates());\n    this.appendParser(new L.GML.PointNode());\n  },\n\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    var firstChild = element.firstElementChild;\n    var coords = [];\n    var tagName = firstChild.tagName;\n    if (tagName === 'gml:pos' || tagName === 'gml:Point') {\n      var childParser = this.parsers[tagName];\n      var elements = element.getElementsByTagNameNS(L.XmlUtil.namespaces.gml, tagName.split(':').pop());\n      for (var i = 0; i < elements.length; i++) {\n        coords.push(childParser.parse(elements[i], options));\n      }\n    }\n    else {\n      coords = this.parseElement(firstChild, options);\n    }\n\n    return coords;\n  }\n});\n\nL.GML.LinearRing = L.GML.PointSequence.extend({\n\n  elementTag: 'gml:LinearRing',\n\n  /**\n   * Parse element into array of coordinates\n   *\n   * @method parse\n   * @param {Element} element\n   * @param {Object} options\n   * @return {Array} array of L.Point\n   */\n  parse: function (element, options) {\n    var coords = L.GML.PointSequence.prototype.parse.call(this, element, options);\n\n    // for leaflet polygons its not recommended insert additional last point equal to the first one,\n    // but GML linearRing contains it\n    coords.pop();\n    return coords;\n  }\n});\n\nL.GML.LineStringNode = L.GML.PointSequence.extend({\n  elementTag: 'gml:LineString'\n});\n\nL.GML.PolygonNode = L.GML.Geometry.extend({\n\n  elementTag: 'gml:Polygon',\n\n  initialize: function () {\n    this.linearRingParser = new L.GML.LinearRing();\n  },\n\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    var coords = [];\n    for (var i = 0; i < element.children.length; i++) {\n\n      // there can be exterior and interior, by GML standard but for leaflet its not significant\n      var child = element.children[i];\n      coords.push(this.linearRingParser.parse(child.firstElementChild, options));\n    }\n\n    return coords;\n  }\n});\n\nL.GML.CoordsToLatLngMixin = {\n  transform: function (coordinates, options) {\n    if (Array.isArray(coordinates[0])) {\n      var latLngs = [];\n      for (var i = 0; i < coordinates.length; i++) {\n        latLngs.push(this.transform(coordinates[i], options));\n      }\n\n      return latLngs;\n    }\n\n    return options.coordsToLatLng(coordinates);\n  }\n};\n\nL.GML.Point = L.GML.PointNode.extend({\n  includes: L.GML.CoordsToLatLngMixin,\n\n  parse: function (element, options) {\n    var coords = L.GML.PointNode.prototype.parse.call(this, element, options);\n    var layer = new L.Marker();\n    layer.setLatLng(this.transform(coords, options));\n    return layer;\n  }\n});\n\nL.GML.LineString = L.GML.LineStringNode.extend({\n\n  includes: L.GML.CoordsToLatLngMixin,\n\n  /**\n   * Get layer from passed element\n   *\n   * @method parse\n   * @param {Element} element\n   * @param {Object} options\n   * @return {L.Layer} polyline layer\n   */\n  parse: function (element, options) {\n    var layer = new L.Polyline([]);\n    var coordinates = L.GML.LineStringNode.prototype.parse.call(this, element);\n    layer.setLatLngs(this.transform(coordinates, options));\n    return layer;\n  }\n});\n\nL.GML.Polygon = L.GML.PolygonNode.extend({\n\n  includes: L.GML.CoordsToLatLngMixin,\n\n  parse: function (element, options) {\n    var layer = new L.Polygon([]);\n    var coordinates = L.GML.PolygonNode.prototype.parse.call(this, element, options);\n    layer.setLatLngs(this.transform(coordinates, options));\n    return layer;\n  }\n});\n\nL.GML.MultiGeometry = L.GML.Geometry.extend({\n  includes: [L.GML.ParserContainerMixin, L.GML.CoordsToLatLngMixin],\n\n  initialize: function () {\n    this.initializeParserContainer();\n  },\n\n  /**\n   * Convert element to array of geometry objects\n   *\n   * @method parse\n   * @param {Element} element\n   * @param {options}\n   * @return {Array} array of geometry objects\n   */\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    var childObjects = [];\n    for (var i = 0; i < element.children.length; i++) {\n      var geometryMember = element.children[i];\n\n      for (var j = 0; j < geometryMember.children.length; j++) {\n        var singleGeometry = geometryMember.children[j];\n        childObjects.push(this.parseElement(singleGeometry, options));\n      }\n    }\n\n    return this.transform(childObjects, options);\n  }\n});\n\nL.GML.AbstractMultiPolyline = L.GML.MultiGeometry.extend({\n\n  initialize: function () {\n    L.GML.MultiGeometry.prototype.initialize.call(this);\n    this.appendParser(new L.GML.LineStringNode());\n  },\n\n  parse: function (element, options) {\n    var latLngs = L.GML.MultiGeometry.prototype.parse.call(this, element, options);\n    var layer = new L.Polyline([]);\n    layer.setLatLngs(latLngs);\n    return layer;\n  }\n});\n\nL.GML.AbstractMultiPolygon = L.GML.MultiGeometry.extend({\n\n  initialize: function () {\n    L.GML.MultiGeometry.prototype.initialize.call(this);\n    this.appendParser(new L.GML.PolygonNode());\n  },\n\n  parse: function (element, options) {\n    var latLngs = L.GML.MultiGeometry.prototype.parse.call(this, element, options);\n    var layer = new L.Polygon([]);\n    layer.setLatLngs(latLngs);\n    return layer;\n  }\n});\n\nL.GML.MultiLineString = L.GML.AbstractMultiPolyline.extend({\n  elementTag: 'gml:MultiLineString'\n});\n\nL.GML.MultiCurve = L.GML.AbstractMultiPolyline.extend({\n  elementTag: 'gml:MultiCurve'\n});\n\nL.GML.MultiPolygon = L.GML.AbstractMultiPolygon.extend({\n  elementTag: 'gml:MultiPolygon'\n});\n\nL.GML.MultiSurface = L.GML.AbstractMultiPolygon.extend({\n  elementTag: 'gml:MultiSurface'\n});\n\nL.GML.MultiPoint = L.GML.MultiGeometry.extend({\n  elementTag: 'gml:MultiPoint',\n\n  initialize: function () {\n    L.GML.MultiGeometry.prototype.initialize.call(this);\n    this.appendParser(new L.GML.PointNode());\n  },\n\n  parse: function (element, options) {\n    var coordinates = L.GML.MultiGeometry.prototype.parse.call(this, element, options);\n    var multiPoint = new L.FeatureGroup();\n    for (var i = 0; i < coordinates.length; i++) {\n      var point = new L.Marker();\n      point.setLatLng(coordinates[i]);\n      multiPoint.addLayer(point);\n    }\n\n    return multiPoint;\n  }\n});\n\nL.GML.FeatureType = L.Class.extend({\n  options: {\n    geometryField: 'Shape',\n  },\n\n  primitives: [\n    {\n      types: ['byte', 'short', 'int', 'integer', 'long', 'float', 'double', 'decimal'],\n      parse: function (input) {\n        if (input === 0) {\n          return 0;\n        }\n        input = String.prototype.trim.call(input || '');\n        return input === '' ? null : Number(input);\n      },\n      validate: function (parsedValue) {\n        // Invalid number can be detected by isNaN check.\n        return !isNaN(parsedValue);\n      },\n      type: 'number'\n    },\n    {\n      types: ['string'],\n      parse: function (input) {\n        return input;\n      },\n      validate: function (parsedValue) {\n        // Any value is valid for 'string' type.\n        return true;\n      },\n      type: 'string'\n    },\n    {\n      types: ['boolean'],\n      parse: function (input) {\n        input = String.prototype.trim.call(input || '').toLowerCase();\n        return input !== 'false';\n      },\n      validate: function (parsedValue) {\n        // Any value is valid for 'boolean' type if parser parses it like so: input !== 'false'.\n        return true;\n      },\n      type: 'boolean'\n    },\n    {\n      types: ['date', 'time', 'datetime'],\n      parse: function (input) {\n        input = String.prototype.trim.call(input || '');\n        return input === '' ? null : new Date(input);\n      },\n      validate: function (parsedValue) {\n        // Invalid date also can be detected by isNaN check.\n        return !isNaN(parsedValue);\n      },\n      type: 'date'\n    }\n  ],\n\n  initialize: function (options) {\n    L.setOptions(this, options);\n\n    this.fields = {};\n    this.fieldValidators = {};\n    this.fieldTypes = {};\n    this.geometryFields = {};\n  },\n\n  appendField: function (name, type) {\n    var that = this;\n    type = String.prototype.toLowerCase.call(type || '');\n\n    this.primitives.forEach(function (primitive) {\n      if (primitive.types.indexOf(type) !== -1) {\n        that.fields[name] = primitive.parse;\n        that.fieldValidators[name] = primitive.validate;\n        that.fieldTypes[name] = primitive.type;\n      }\n    });\n  },\n\n  parse: function (feature) {\n    var properties = {};\n    for (var i = 0; i < feature.children.length; i++) {\n      var node = feature.children[i];\n      var propertyName = node.tagName.split(':').pop();\n      if (propertyName === this.options.geometryField) {\n        continue;\n      }\n\n      var parseField = this.fields[propertyName];\n      if (!parseField) {\n        this.appendField(propertyName, 'string');\n        parseField = this.fields[propertyName];\n      }\n\n      properties[propertyName] = parseField(node.textContent);\n    }\n\n    return {\n      type: 'Feature',\n      properties: properties,\n      id: feature.attributes['gml:id'].value\n    };\n  }\n});\n\nL.Format.GML = L.Format.Base.extend({\n\n  includes: L.GML.ParserContainerMixin,\n\n  outputFormat: 'text/xml; subtype=gml/3.1.1',\n\n  initialize: function (options) {\n    L.Format.Base.prototype.initialize.call(this, options);\n    this.initializeParserContainer();\n    this.appendParser(new L.GML.Point());\n    this.appendParser(new L.GML.LineString());\n    this.appendParser(new L.GML.Polygon());\n    this.appendParser(new L.GML.MultiLineString());\n    this.appendParser(new L.GML.MultiPolygon());\n    this.appendParser(new L.GML.MultiCurve());\n    this.appendParser(new L.GML.MultiSurface());\n    this.appendParser(new L.GML.MultiPoint());\n  },\n\n  /**\n   * Convert raw data to leaflet layers array\n   *\n   * @method responseToLayers\n   * @param {string} rawData\n   * @return {Array} Array of leaflet layers\n   */\n  responseToLayers: function (rawData) {\n    var layers = [];\n    var xmlDoc = L.XmlUtil.parseXml(rawData);\n    var featureCollection = xmlDoc.documentElement;\n    var featureMemberNodes = featureCollection.getElementsByTagNameNS(L.XmlUtil.namespaces.gml, 'featureMember');\n    for (var i = 0; i < featureMemberNodes.length; i++) {\n      var feature = featureMemberNodes[i].firstElementChild;\n      var featureAsLayer = this.processFeature(feature);\n      if (featureAsLayer) {\n        layers.push(featureAsLayer);\n      }\n    }\n\n    var featureMembersNode = featureCollection.getElementsByTagNameNS(L.XmlUtil.namespaces.gml, 'featureMembers');\n    if (featureMembersNode.length > 0) {\n      var features = featureMembersNode[0].children;\n      for (var j = 0; j < features.length; j++) {\n        var node = features[j];\n        var nodeAsLayer = this.processFeature(node);\n        if (nodeAsLayer) {\n          layers.push(nodeAsLayer);\n        }\n      }\n    }\n\n    return layers;\n  },\n\n  /**\n   * Create layer and set its properties from xml feature element\n   *\n   * @method processFeature\n   * @param {Element} feature\n   * @return {Layer} leaflet layer with \"feature\" property with feature fields values\n   * @private\n   */\n  processFeature: function (feature) {\n    var layer = this.generateLayer(feature);\n    if (!layer) {\n      return null;\n    }\n\n    layer.feature = this.featureType.parse(feature);\n    return layer;\n  },\n\n  /**\n   * Create leaflet layer from xml feature element\n   *\n   * @method generateLayer\n   * @param {Element} feature\n   * @return {Layer} leaflet layer\n   * @private\n   */\n  generateLayer: function (feature) {\n    var geometryField = feature.getElementsByTagNameNS(this.namespaceUri, this.options.geometryField)[0];\n    if (!geometryField) {\n      console.log(\n        'Geometry field \\'' + this.options.geometryField + '\\' doesn\\' exist inside received feature: \\'' + feature.innerHTML + '\\', ' +\n        'so feature will be skipped and won\\'t be converted into leaflet layer');\n\n      return null;\n    }\n\n    return this.parseElement(geometryField.firstElementChild, this.options);\n  }\n});\n\nL.Util.project = function (crs, latlngs) {\n  if (L.Util.isArray(latlngs)) {\n    var result = [];\n    latlngs.forEach(function (latlng) {\n      result.push(L.Util.project(crs, latlng));\n    });\n\n    return result;\n  } else {\n    return crs.projection.project(latlngs);\n  }\n};\n\n// 1.0.1 <=> 1.1.0 <=> 1.2.0 compatibility.\nL.Util.isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat;\n\nL.GmlUtil = {\n\n  /**\n   * Create gml:pos Element with passed coordinates\n   *\n   * @method posNode\n   * @param {L.Point} coord\n   * @return {Element} gml:pos\n   */\n  posNode: function (coord) {\n    return L.XmlUtil.createElementNS('gml:pos', { srsDimension: 2 }, { value: coord.x + ' ' + coord.y });\n  },\n\n  /**\n   * Create gml:posList Element from passed coordinates\n   *\n   * @method posListNode\n   * @param {Array} coords Array of L.Point that should be represent as GML\n   * @param {boolean} close Should posList be closed, uses when need do polygon\n   * @return {Element} gml:posList Element\n   */\n  posListNode: function (coords, close) {\n    var localcoords = [];\n    coords.forEach(function (coord) {\n      localcoords.push(coord.x + ' ' + coord.y);\n    });\n    if (close && coords.length > 0) {\n      var coord = coords[0];\n      localcoords.push(coord.x + ' ' + coord.y);\n    }\n\n    var posList = localcoords.join(' ');\n    return L.XmlUtil.createElementNS('gml:posList', {}, { value: posList });\n  }\n};\n\nL.CircleMarker.include({\n  toGml: function(crs) {\n    var node = L.XmlUtil.createElementNS('gml:Point', {srsName: crs.code});\n    node.appendChild(L.GmlUtil.posNode(L.Util.project(crs, this.getLatLng())));\n    return node;\n  }\n});\n\nL.LatLngBounds.prototype.toGml = function (crs) {\n  var projectedSW = crs.project(this.getSouthWest());\n  var projectedNE = crs.project(this.getNorthEast());\n\n  var envelopeElement = L.XmlUtil.createElementNS('gml:Envelope', { srsName: crs.code });\n  envelopeElement.appendChild(L.XmlUtil.createElementNS('gml:lowerCorner', {}, { value: projectedSW.x + ' ' + projectedSW.y }));\n  envelopeElement.appendChild(L.XmlUtil.createElementNS('gml:upperCorner', {}, { value: projectedNE.x + ' ' + projectedNE.y }));\n\n  return envelopeElement;\n};\n\nL.Marker.include({\n  toGml: function (crs) {\n    var node = L.XmlUtil.createElementNS('gml:Point', {srsName: crs.code});\n    node.appendChild(L.GmlUtil.posNode(L.Util.project(crs, this.getLatLng())));\n    return node;\n  }\n});\n\nL.Polygon.include({\n  toGml: function (crs, forceMulti) {\n    var polygons = this.getLatLngs();\n    var gmlPolygons = [];\n\n    for (var i = 0; i < polygons.length; i++) {\n      var polygonCoordinates = polygons[i];\n      var flat = L.Util.isFlat(polygonCoordinates);\n      var node = L.XmlUtil.createElementNS('gml:Polygon', {srsName: crs.code, srsDimension: 2});\n      node.appendChild(L.XmlUtil.createElementNS('gml:exterior'))\n        .appendChild(L.XmlUtil.createElementNS('gml:LinearRing', {srsDimension: 2}))\n        .appendChild(L.GmlUtil.posListNode(L.Util.project(crs, flat ? polygonCoordinates : polygonCoordinates[0]), true));\n\n      if (!flat) {\n        for (var hole = 1; hole < polygonCoordinates.length; hole++) {\n          node.appendChild(L.XmlUtil.createElementNS('gml:interior'))\n            .appendChild(L.XmlUtil.createElementNS('gml:LinearRing', {srsDimension: 2}))\n            .appendChild(L.GmlUtil.posListNode(L.Util.project(crs, polygonCoordinates[hole]), true));\n        }\n      }\n\n      gmlPolygons.push(node);\n    }\n\n    if (gmlPolygons.length === 1 && !forceMulti) return gmlPolygons[0];\n\n    // else make multipolygon\n    var multi = L.XmlUtil.createElementNS('gml:MultiSurface', {srsName: crs.code, srsDimension: 2});\n    var collection = multi.appendChild(L.XmlUtil.createElementNS('gml:surfaceMembers'));\n    for (var p = 0; p < gmlPolygons.length; p++) {\n      collection.appendChild(gmlPolygons[p]);\n    }\n\n    return multi;\n  }\n});\n\nL.Polyline.include({\n  _lineStringNode: function (crs, latlngs) {\n    var node = L.XmlUtil.createElementNS('gml:LineString', {srsName: crs.code, srsDimension: 2});\n    node.appendChild(L.GmlUtil.posListNode(L.Util.project(crs, latlngs), false));\n    return node;\n  },\n\n  toGml: function (crs, forceMulti) {\n    var latLngs = this.getLatLngs();\n    var gmlElements = [];\n\n    if (L.Util.isFlat(latLngs)) {\n       gmlElements.push(this._lineStringNode(crs, latLngs));\n    } else {\n      for (var i = 0; i < latLngs.length; i++) {\n        gmlElements.push(this._lineStringNode(crs, latLngs[i]));\n      }\n    }\n\n    if(gmlElements.length === 1 && !forceMulti) {\n      return gmlElements[0];\n    }\n\n    var multi = L.XmlUtil.createElementNS('gml:MultiCurve', {srsName: crs.code, srsDimension: 2});\n    var collection = multi.appendChild(L.XmlUtil.createElementNS('gml:curveMembers'));\n    for (var lines = 0; lines < gmlElements.length; lines++) {\n      collection.appendChild(gmlElements[lines]);\n    }\n\n    return multi;\n  }\n});\n\nvar PropertiesMixin = {\n  setProperties: function (obj) {\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        this.feature.properties[i] = obj[i];\n      }\n    }\n  },\n  getProperty: function (field) {\n    return this.feature.properties[field];\n  },\n  deleteProperties: function (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (this.feature.properties.hasOwnProperty(arr[i])) {\n        delete this.feature.properties[arr[i]];\n      }\n    }\n  }\n};\nL.Marker.include(PropertiesMixin);\nL.Path.include(PropertiesMixin);\n\nL.WFS = L.FeatureGroup.extend({\n\n  _capabilities: null,\n\n  _boundingBox: null,\n\n  options: {\n    crs: L.CRS.EPSG3857,\n    showExisting: true,\n    geometryField: 'Shape',\n    url: '',\n    version: '1.1.0',\n    typeNS: '',\n    typeName: '',\n    typeNSName: '',\n    maxFeatures: null,\n    filter: null,\n    opacity: 1,\n    fillOpacity: 1,\n    style: {\n      color: 'black',\n      weight: 1,\n      opacity: 1,\n      fillOpacity: 1\n    },\n    namespaceUri: ''\n  },\n\n  state: {},\n\n  initialize: function (options, readFormat) {\n    L.setOptions(this, options);\n\n    this.state = {\n      exist: 'exist'\n    };\n\n    this._layers = {};\n\n    this.readFormat = readFormat || new L.Format.GML({\n      crs: this.options.crs,\n      geometryField: this.options.geometryField\n    });\n\n    this.options.typeNSName = this.namespaceName(this.options.typeName);\n    this.options.srsName = this.options.crs.code;\n\n    this._updateOpacity();\n\n    var that = this;\n    this.describeFeatureType(function () {\n      if (that.options.showExisting) {\n        that.loadFeatures(that.options.filter);\n      }\n    }, function (errorMessage) {\n      that.fire('error', {\n        error: new Error(errorMessage)\n      });\n    });\n  },\n\n  namespaceName: function (name) {\n    return this.options.typeNS + ':' + name;\n  },\n\n  describeFeatureType: function (successCallback, errorCallback) {\n    var requestData = L.XmlUtil.createElementNS('wfs:DescribeFeatureType', {\n      service: 'WFS',\n      version: this.options.version\n    });\n    requestData.appendChild(L.XmlUtil.createElementNS('TypeName', {}, {\n      value: this.options.typeNSName\n    }));\n\n    var that = this;\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(requestData),\n      headers: this.options.headers || {},\n      success: function (data) {\n        // If some exception occur, WFS-service can response successfully, but with ExceptionReport,\n        // and such situation must be handled.\n        var exceptionReport = L.XmlUtil.parseOwsExceptionReport(data);\n        if (exceptionReport) {\n          if (typeof (errorCallback) === 'function') {\n            errorCallback(exceptionReport.message);\n          }\n\n          return;\n        }\n\n        var xmldoc = L.XmlUtil.parseXml(data);\n        var featureInfo = xmldoc.documentElement;\n        that.readFormat.setFeatureDescription(featureInfo);\n        that.options.namespaceUri = featureInfo.attributes.targetNamespace.value;\n        if (typeof (successCallback) === 'function') {\n          successCallback();\n        }\n      },\n      error: function (errorMessage) {\n        if (typeof (errorCallback) === 'function') {\n          errorCallback(errorMessage);\n        }\n      }\n    });\n  },\n\n  getFeature: function (filter) {\n    var request = L.XmlUtil.createElementNS('wfs:GetFeature', {\n      service: 'WFS',\n      version: this.options.version,\n      maxFeatures: this.options.maxFeatures,\n      outputFormat: this.readFormat.outputFormat\n    });\n\n    var query = request.appendChild(L.XmlUtil.createElementNS('wfs:Query', {\n      typeName: this.options.typeNSName,\n      srsName: this.options.srsName\n    }));\n\n    if (filter) {\n      query.appendChild(L.filter(filter));\n    }\n\n    return request;\n  },\n\n  loadFeatures: function (filter) {\n    var that = this;\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(that.getFeature(filter)),\n      headers: this.options.headers || {},\n      success: function (responseText) {\n        // If some exception occur, WFS-service can response successfully, but with ExceptionReport,\n        // and such situation must be handled.\n        var exceptionReport = L.XmlUtil.parseOwsExceptionReport(responseText);\n        if (exceptionReport) {\n          that.fire('error', {\n            error: new Error(exceptionReport.message)\n          });\n\n          return that;\n        }\n\n        // Request was truly successful (without exception report),\n        // so convert response to layers.\n        var layers = that.readFormat.responseToLayers(responseText, {\n          coordsToLatLng: that.options.coordsToLatLng,\n          pointToLayer: that.options.pointToLayer\n        });\n\n        if (typeof that.options.style === \"function\") {\n          layers.forEach(function (element) {\n            element.state = that.state.exist;\n            if (element.setStyle) {\n              element.setStyle(that.options.style(element));\n            }\n            that.addLayer(element);\n          });\n        } else {\n          layers.forEach(function (element) {\n            element.state = that.state.exist;\n            that.addLayer(element);\n          });\n          that.setStyle(that.options.style);\n        }\n\n        that.fire('load', {\n          responseText: responseText\n        });\n\n        return that;\n      },\n      error: function (errorMessage) {\n        that.fire('error', {\n          error: new Error(errorMessage)\n        });\n\n        return that;\n      }\n    });\n  },\n\n  getCapabilities: function (successCallback, errorCallback) {\n    var capabilities = this._capabilities;\n\n    // Check if capabilities were already received & cached.\n    if (capabilities) {\n      if (typeof (successCallback) === 'function') {\n        successCallback(capabilities);\n\n        return;\n      }\n    }\n\n    var requestData = L.XmlUtil.createElementNS('wfs:GetCapabilities', {\n      service: 'WFS',\n      version: this.options.version\n    });\n\n    var that = this;\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(requestData),\n      headers: this.options.headers || {},\n      success: function (data) {\n        // If some exception occur, WFS-service can response successfully, but with ExceptionReport,\n        // and such situation must be handled.\n        var exceptionReport = L.XmlUtil.parseOwsExceptionReport(data);\n        if (exceptionReport) {\n          if (typeof (errorCallback) === 'function') {\n            errorCallback(new Error(exceptionReport.message));\n          }\n\n          return;\n        }\n\n        try {\n          // Request was truly successful (without exception report), parse WFS_Capabilities.\n          capabilities = L.XmlUtil.parseXml(data).documentElement;\n        } catch (error) {\n          // If parsing failed.\n          if (typeof (errorCallback) === 'function') {\n            errorCallback(error);\n          }\n\n          return;\n        }\n\n        // Cache received capabilities.\n        that._capabilities = capabilities;\n\n        if (typeof (successCallback) === 'function') {\n          successCallback(capabilities);\n        }\n      },\n      error: function (errorMessage) {\n        if (typeof (errorCallback) === 'function') {\n          errorCallback(new Error(errorMessage));\n        }\n      }\n    });\n  },\n\n  getBoundingBox: function (successCallback, errorCallback) {\n    var boundingBox = this._boundingBox;\n\n    // Check if bounding box was already received & cached.\n    if (boundingBox) {\n      if (typeof (successCallback) === 'function') {\n        successCallback(boundingBox);\n\n        return;\n      }\n    }\n\n    var that = this;\n    this.getCapabilities(function (capabilities) {\n      var featureTypeListElement = capabilities.getElementsByTagName('FeatureTypeList')[0];\n\n      // Extract all 'FeatureType' nodes to list.\n      var featureTypeList = featureTypeListElement.getElementsByTagName('FeatureType');\n\n      for (var i = 0, len = featureTypeList.length; i < len; i++) {\n        var featureType = featureTypeList[i];\n\n        // Extract current FeatureType's name.\n        var featureTypeNSName = L.XmlUtil.getNodeText(featureType.getElementsByTagName('Name')[0]);\n\n        // Find node with current layer instance's name and namespace.\n        if (featureTypeNSName === that.options.typeNSName) {\n          // The <WGS84BoundingBox> element is used to indicate the edges of an\n          // enclosing rectangle in decimal degrees of latitude and longitude in WGS84.\n          var wgs84BoundingBox = featureType.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'WGS84BoundingBox')[0];\n          var lowerCornerElement = wgs84BoundingBox.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'LowerCorner')[0];\n          var upperCornerElement = wgs84BoundingBox.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'UpperCorner')[0];\n\n          // Corner node's inner text format is like '-74.047185 40.679648', Lng and Lat with a space between.\n          var lowerCorner = L.XmlUtil.getNodeText(lowerCornerElement);\n          var upperCorner = L.XmlUtil.getNodeText(upperCornerElement);\n\n          // Extract LngLats and reverse it to LatLngs.\n          var sw = lowerCorner.split(' ').reverse();\n          var ne = upperCorner.split(' ').reverse();\n\n          // Wrap it into LatLngBounds.\n          boundingBox = L.latLngBounds([sw, ne]);\n\n          break;\n        }\n      }\n\n      // Cache received and calculated bounding box.\n      that._boundingBox = boundingBox;\n\n      if (typeof (successCallback) === 'function') {\n        successCallback(boundingBox);\n      }\n    }, function (errorMessage) {\n      if (typeof (errorCallback) === 'function') {\n        errorCallback(new Error(errorMessage));\n      }\n    });\n  },\n\n  setOpacity: function (opacity, fillOpacity) {\n    this.options.opacity = opacity;\n    this.options.fillOpacity = fillOpacity || opacity;\n\n    this._updateOpacity();\n\n    return this;\n  },\n\n  _updateOpacity: function () {\n    var style = L.extend(this.options.style || {}, {\n      opacity: this.options.opacity,\n      fillOpacity: this.options.fillOpacity\n    });\n\n    this.setStyle(style);\n  }\n});\n\nL.wfs = function (options, readFormat) {\n  return new L.WFS(options, readFormat);\n};\n\nL.WFST = L.WFS.extend({\n  options: {\n    forceMulti: false\n  },\n\n  initialize: function (options, readFormat) {\n    L.WFS.prototype.initialize.call(this, options, readFormat);\n    this.state = L.extend(this.state, {\n      insert: 'insertElement',\n      update: 'updateElement',\n      remove: 'removeElement'\n    });\n\n    this.changes = {};\n  },\n\n  addLayer: function (layer) {\n    L.FeatureGroup.prototype.addLayer.call(this, layer);\n    if (!layer.feature) {\n      layer.feature = { properties: {} };\n    }\n\n    if (!layer.state) {\n      layer.state = this.state.insert;\n      var id = this.getLayerId(layer);\n      this.changes[id] = layer;\n    }\n    return this;\n  },\n\n  removeLayer: function (layer) {\n    L.FeatureGroup.prototype.removeLayer.call(this, layer);\n\n    var id = this.getLayerId(layer);\n\n    if (id in this.changes) {\n      var change = this.changes[id];\n      if (change.state === this.state.insert) {\n        delete this.changes[id];\n      }\n      else {\n        change.state = this.state.remove;\n      }\n    }\n    else {\n      layer.state = this.state.remove;\n      this.changes[id] = layer;\n    }\n  },\n\n  editLayer: function (layer) {\n    if (layer.state !== this.state.insert) {\n      layer.state = this.state.update;\n    }\n\n    var id = this.getLayerId(layer);\n    this.changes[id] = layer;\n    return this;\n  },\n\n  save: function () {\n    var transaction = L.XmlUtil.createElementNS('wfs:Transaction', { service: 'WFS', version: this.options.version });\n\n    var inserted = [];\n\n    for (var id in this.changes) {\n      var layer = this.changes[id];\n      var action = this[layer.state](layer);\n      transaction.appendChild(action);\n\n      if (layer.state === this.state.insert) {\n        inserted.push(layer);\n      }\n    }\n\n    var that = this;\n\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(transaction),\n      headers: this.options.headers || {},\n      withCredentials: true,\n      success: function (data) {\n        var xmlDoc = L.XmlUtil.parseXml(data);\n        var exception = L.XmlUtil.parseOwsExceptionReport(xmlDoc);\n        if(exception !== null) {\n          that.fire('save:failed', exception);\n          return;\n        }\n\n        var insertResult = L.XmlUtil.evaluate('//wfs:InsertResults/wfs:Feature/ogc:FeatureId/@fid', xmlDoc);\n        var insertedIds = [];\n        var id = insertResult.iterateNext();\n        while (id) {\n          insertedIds.push(new L.Filter.GmlObjectID(id.value));\n          id = insertResult.iterateNext();\n        }\n\n        inserted.forEach(function (layer) {\n          L.FeatureGroup.prototype.removeLayer.call(that, layer);\n        });\n\n        that.once('load', function () {\n          that.fire('save:success');\n          that.changes = {};\n        });\n\n        that.loadFeatures(insertedIds);\n      },\n      error: function (data) {\n        that.fire('save:failed', data);\n      }\n    });\n\n    return this;\n  }\n});\n\nL.wfst = function (options, readFormat) {\n  return new L.WFST(options, readFormat);\n};\n\nL.WFST.include({\n  gmlFeature: function (layer) {\n    var featureNode = L.XmlUtil.createElementNS(this.options.typeNSName, {}, { uri: this.options.namespaceUri });\n    var feature = layer.feature;\n    for (var propertyName in feature.properties) {\n      featureNode.appendChild(this.gmlProperty(propertyName,\n        feature.properties[propertyName]));\n    }\n\n    featureNode.appendChild(\n      this.gmlProperty(\n        this.options.geometryField,\n        layer.toGml(\n          this.options.crs,\n          this.options.forceMulti\n        )\n      )\n    );\n\n    return featureNode;\n  },\n\n  /**\n     Returns element with name as tag and value as innerText or child element\n     ```xml\n     <name>value<name>\n     ```\n\n     or if value is element\n\n     ```xml\n     <name><value /><name>\n     ```\n\n     @method gmlProperty\n     @param {string} name Name of property\n     @param {Object} value Value of property\n     @return {Element} simple property element <name>value<name>\n   */\n  gmlProperty: function (name, value) {\n    var propertyNode = L.XmlUtil.createElementNS(this.namespaceName(name));\n    if (value instanceof Element) {\n      propertyNode.appendChild(value);\n    }\n    else if (value === null || value === undefined || value === '') {\n      L.XmlUtil.setAttributes(propertyNode, { 'xsi:nil': true });\n    } else {\n      propertyNode.appendChild(L.XmlUtil.createTextNode(value));\n    }\n\n    return propertyNode;\n  },\n\n  /**\n    Returns wfs:Property element with passed property name and value:\n    ```xml\n    <wfs:Property>\n      <wfs:Name>%name%</wfs:Name>\n      <wfs:Value>%value%</wfs:Value>\n    </wfs:Property>\n    ```\n\n    @method wfsProperty\n    @param {string} name Property name\n    @param {Object} value Property value, if passed Element object it will be added as child element of value\n    @return {Element}\n   */\n  wfsProperty: function (name, value) {\n    var propertyNode = L.XmlUtil.createElementNS('wfs:Property');\n    propertyNode.appendChild(L.XmlUtil.createElementNS('wfs:Name', {}, { value: name }));\n    var valueNode = L.XmlUtil.createElementNS('wfs:Value');\n    if (value instanceof Element) {\n      valueNode.appendChild(value);\n    }\n    else {\n      valueNode.appendChild(L.XmlUtil.createTextNode(value));\n    }\n\n    propertyNode.appendChild(valueNode);\n\n    return propertyNode;\n  }\n});\n\nL.WFST.include({\n\n  /**\n    Returns wfs:Insert element for passed layer\n\n    @method insertElement\n    @param {Layer} layer\n    @return {Element} wfs:Insert element with layer\n   */\n  insertElement: function (layer) {\n    var node = L.XmlUtil.createElementNS('wfs:Insert');\n    node.appendChild(this.gmlFeature(layer));\n    return node;\n  },\n\n  /**\n    Returns wfs:Update element for specified layer\n\n    @method updateElement\n    @param {Layer} layer\n    @return {Element} wfs:Update element for passed layer properties limited with filter by feature.id\n   */\n  updateElement: function (layer) {\n    var node = L.XmlUtil.createElementNS('wfs:Update', { typeName: this.options.typeNSName });\n    var feature = layer.feature;\n    for (var propertyName in feature.properties) {\n      if (feature.properties.hasOwnProperty(propertyName)) {\n        node.appendChild(this.wfsProperty(propertyName, feature.properties[propertyName]));\n      }\n    }\n\n    node.appendChild(\n      this.wfsProperty(\n        this.namespaceName(this.options.geometryField),\n        layer.toGml(this.options.crs, this.options.forceMulti)\n      )\n    );\n\n    var idFilter = new L.Filter.GmlObjectID(layer.feature.id);\n    node.appendChild(L.filter(idFilter));\n    return node;\n  },\n\n  removeElement: function (layer) {\n    var node = L.XmlUtil.createElementNS('wfs:Delete', { typeName: this.options.typeNSName });\n    var idFilter = new L.Filter.GmlObjectID(layer.feature.id);\n    node.appendChild(L.filter(idFilter));\n    return node;\n  }\n});\n\n\n})(window, document);\n\n/***/ })\n\n/******/ })});;\n\n\n// WEBPACK FOOTER //\n// plugins/wfst.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dist/dmap/leaflet/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 181);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7b19f38a437100774b0e","/*! leaflet-wfst 2.0.1-beta.21 2018-05-11 */\n(function(window, document, undefined) {\n\n\"use strict\";\n\nL.XmlUtil = {\n  namespaces: {\n    xlink: 'http://www.w3.org/1999/xlink',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xsd: 'http://www.w3.org/2001/XMLSchema',\n    xsi: 'http://www.w3.org/2001/XMLSchema-instance',\n    wfs: 'http://www.opengis.net/wfs',\n    gml: 'http://www.opengis.net/gml',\n    ogc: 'http://www.opengis.net/ogc',\n    ows: 'http://www.opengis.net/ows'\n  },\n\n  // TODO: find another way to create a new document with doctype text/xml?\n  xmldoc: (new DOMParser()).parseFromString('<root />', 'text/xml'),\n\n  setAttributes: function (node, attributes) {\n    for (var name in attributes) {\n      if (attributes[name] != null && attributes[name].toString) {\n        var value = attributes[name].toString();\n        var uri = this.namespaces[name.substring(0, name.indexOf(':'))] || null;\n        node.setAttributeNS(uri, name, value);\n      }\n    }\n  },\n\n  evaluate: function (xpath, xml) {\n    var xmlDoc = xml;\n    if (!(xmlDoc instanceof Document)) {\n      xmlDoc = this.parseXml(xml);\n    }\n\n    var xpe = new XPathEvaluator();\n    var nsResolver = xpe.createNSResolver(xmlDoc.documentElement);\n\n    return xpe.evaluate(xpath, xmlDoc, nsResolver, XPathResult.ANY_TYPE, null);\n  },\n\n  createElementNS: function (name, attributes, options) {\n    options = options || {};\n\n    var uri = options.uri;\n\n    if (!uri) {\n      uri = this.namespaces[name.substring(0, name.indexOf(':'))];\n    }\n\n    if (!uri) {\n      uri = this.namespaces[options.prefix];\n    }\n\n    var node = uri ? this.xmldoc.createElementNS(uri, name) : this.xmldoc.createElement(name);\n\n    if (attributes) {\n      this.setAttributes(node, attributes);\n    }\n\n    if (options.value != null) {\n      node.appendChild(this.xmldoc.createTextNode(options.value));\n    }\n\n    return node;\n  },\n\n  createTextNode: function (value) {\n    if(value === null || value === undefined) {\n      value = '';\n    } else if(value instanceof Date) {\n      value = value.toISOString();\n    }\n\n    return this.xmldoc.createTextNode(value);\n  },\n\n  getNodeText: function (node) {\n    if (!node) {\n      return '';\n    }\n\n    return node.innerText || node.textContent || node.text;\n  },\n\n  serializeXmlDocumentString: function (node) {\n    var doc = document.implementation.createDocument('', '', null);\n    doc.appendChild(node);\n    var serializer = new XMLSerializer();\n    return serializer.serializeToString(doc);\n  },\n\n  serializeXmlToString: function (node) {\n    var serializer = new XMLSerializer();\n    return serializer.serializeToString(node);\n  },\n\n  parseXml: function (rawXml) {\n    if (typeof window.DOMParser !== 'undefined') {\n      return (new window.DOMParser()).parseFromString(rawXml, 'text/xml');\n    } else if (typeof window.ActiveXObject !== 'undefined' && new window.ActiveXObject('Microsoft.XMLDOM')) {\n      var xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');\n      xmlDoc.async = 'false';\n      xmlDoc.loadXML(rawXml);\n      return xmlDoc;\n    } else {\n      throw new Error('No XML parser found');\n    }\n  },\n\n  parseOwsExceptionReport: function (xml) {\n    var xmlDoc = xml;\n    if (!(xmlDoc instanceof Document)) {\n      xmlDoc = this.parseXml(xml);\n    }\n\n    var exceptionReportElement = xmlDoc.documentElement;\n    if (!exceptionReportElement || exceptionReportElement.tagName !== 'ows:ExceptionReport') {\n      return null;\n    }\n\n    var exceptionReport = {\n      exceptions: [],\n      message: ''\n    };\n\n    var exceptionsNodes = exceptionReportElement.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'Exception');\n    for (var i = 0, exceptionsNodesCount = exceptionsNodes.length; i < exceptionsNodesCount; i++) {\n      var exceptionNode = exceptionsNodes[i];\n      var exceptionCode = exceptionNode.getAttribute('exceptionCode');\n      var exceptionsTextNodes = exceptionNode.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'ExceptionText');\n      var exception = {\n        code: exceptionCode,\n        text: ''\n      };\n\n      for (var j = 0, textNodesCount = exceptionsTextNodes.length; j < textNodesCount; j++) {\n        var exceptionTextNode = exceptionsTextNodes[j];\n        var exceptionText = exceptionTextNode.innerText || exceptionTextNode.textContent || exceptionTextNode.text;\n\n        exception.text += exceptionText;\n        if (j < textNodesCount - 1) {\n          exception.text += '. ';\n        }\n      }\n\n      exceptionReport.message += exception.code + ' - ' + exception.text;\n      if (i < exceptionsNodesCount - 1) {\n        exceptionReport.message += ' ';\n      }\n\n      exceptionReport.exceptions.push(exception);\n    }\n\n    return exceptionReport;\n  }\n};\n\nL.Util.request = function (options) {\n  options = L.extend({\n    async: true,\n    method: 'POST',\n    data: '',\n    params: {},\n    headers: {},\n    url: window.location.href,\n    withCredentials: false,\n    success: function (data) {\n      console.log(data);\n    },\n    error: function (data) {\n      console.log('Ajax request fail');\n      console.log(data);\n    },\n    complete: function () {\n    }\n  }, options);\n\n  // good bye IE 6,7\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        options.success(xhr.responseText);\n      } else {\n        options.error(xhr.responseText);\n      }\n      options.complete();\n    }\n  };\n  xhr.withCredentials = options.withCredentials;\n\n  var url = options.url + L.Util.getParamString(options.params, options.url);\n\n  xhr.open(options.method, url, options.async);\n  for (var header in options.headers) {\n    xhr.setRequestHeader(header, options.headers[header]);\n  }\n\n  xhr.send(options.data);\n};\n\nL.Filter = {};\n\nL.filter = function (filters) {\n  var result = L.XmlUtil.createElementNS('ogc:Filter');\n\n  if (Array.isArray(filters)) {\n    filters.forEach(function (element) {\n      result.appendChild(element instanceof Element ? element : element.toGml());\n    });\n  } else if (filters) {\n    result.appendChild(filters instanceof Element ? filters : filters.toGml());\n  }\n\n  return result;\n};\n\nL.Filter.propertyName = function (value) {\n  return L.XmlUtil.createElementNS('ogc:PropertyName', {}, { value: value });\n};\n\nL.Filter.literal = function (value) {\n  return L.XmlUtil.createElementNS('ogc:Literal', {}, { value: value });\n};\n\nL.Filter.element = function(value) {\n  if(value instanceof Element) {\n    return value;\n  }\n\n  return value.toGml();\n};\n\nL.Filter.propertyElement = function (value) {\n  if (value instanceof Element) {\n    return value;\n  }\n\n  if (value && typeof (value.toGml) === \"function\") {\n    return value.toGml();\n  }\n\n  return L.Filter.propertyName(value);\n};\n\nL.Filter.literalElement = function (value) {\n  if (value instanceof Element) {\n    return value;\n  }\n\n  if (value && typeof (value.toGml) === \"function\") {\n    return value.toGml();\n  }\n\n  return L.Filter.literal(value);\n};\n\nL.Filter.Abstract = L.Class.extend({\n  attributes: {},\n\n  options: {},\n\n  tagName: null,\n\n  buildFilterContent: function() {\n    throw \"Build filter content is abstract and should be implemented\";\n  },\n\n  toGml: function() {\n    var filterElement = L.XmlUtil.createElementNS(this.tagName, this.attributes, this.options);\n    this.buildFilterContent(filterElement);\n    return filterElement;\n  }\n});\n\nL.Filter.BinarySpatial = L.Filter.Abstract.extend({\n  initialize: function (propertyName, value, crs) {\n    this.propertyName = propertyName;\n    this.value = value;\n    this.crs = crs;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyName(this.propertyName));\n    if (typeof(this.value) === \"string\") {\n      filterElement.appendChild(L.Filter.propertyName(this.value));\n    } else {\n      filterElement.appendChild(this.value.toGml(this.crs));\n    }\n    return filterElement;\n  }\n});\n\nL.Filter.Equals = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Equals'\n});\n\nL.Filter.equals = function(options) {\n  return new L.Filter.Equals(options);\n};\n\nL.Filter.Disjoint = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Disjoint'\n});\n\nL.Filter.disjoint = function(options) {\n  return new L.Filter.Disjoint(options);\n};\n\nL.Filter.Touches = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Touches'\n});\n\nL.Filter.touches = function(options) {\n  return new L.Filter.Touches(options);\n};\n\nL.Filter.Within = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Within'\n});\n\nL.Filter.within = function(options) {\n  return new L.Filter.Within(options);\n};\n\nL.Filter.Overlaps = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Overlaps'\n});\n\nL.Filter.overlaps = function(options) {\n  return new L.Filter.Overlaps(options);\n};\n\nL.Filter.Crosses = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Crosses'\n});\n\nL.Filter.crosses = function(options) {\n  return new L.Filter.Crosses(options);\n};\n\nL.Filter.Intersects = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Intersects'\n});\n\nL.Filter.intersects = function(options) {\n  return new L.Filter.Intersects(options);\n};\n\nL.Filter.Contains = L.Filter.BinarySpatial.extend({\n  tagName: 'ogc:Contains'\n});\n\nL.Filter.contains = function(options) {\n  return new L.Filter.Contains(options);\n};\n\nL.Filter.DistanceBuffer = L.Filter.Abstract.extend({\n  initialize: function (propertyName, geometry, crs, distance, units) {\n    this.propertyName = propertyName;\n    this.geomerty = geometry;\n    this.crs = crs;\n    this.distance = distance;\n    this.units = units;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyName(this.propertyName));\n    filterElement.appendChild(this.geomerty.toGml(this.crs));\n    filterElement.appendChild(L.XmlUtil.createElementNS('ogc:Distance', { 'units': this.units }, { value: this.distance }));\n  }\n});\n\nL.Filter.DWithin = L.Filter.DistanceBuffer.extend({\n  tagName: 'ogc:DWithin'\n});\n\nL.Filter.dwithin = function(propertyName, geometry, crs, distance, units) {\n  return new L.Filter.DWithin(propertyName, geometry, crs, distance, units);\n};\n\nL.Filter.Beyond = L.Filter.DistanceBuffer.extend({\n  tagName: 'ogc:Beyond'\n});\n\nL.Filter.beyond = function(propertyName, geometry, crs, distance, units) {\n  return new L.Filter.Beyond(propertyName, geometry, crs, distance, units);\n};\n\nL.Filter.BBox = L.Filter.Abstract.extend({\n  tagName: 'ogc:BBOX',\n\n  geometryField: null,\n\n  bbox: null,\n\n  crs: null,\n\n  initialize: function (geometryField, bbox, crs) {\n    this.bbox = bbox;\n    this.geometryField = geometryField;\n    this.crs = crs;\n  },\n\n  buildFilterContent: function (filterElement) {\n    if (this.geometryField) {\n      filterElement.appendChild(L.Filter.propertyName(this.geometryField));\n    }\n\n    filterElement.appendChild(this.bbox.toGml(this.crs));\n  }\n});\n\nL.Filter.bbox = function (geometryField, bbox, crs) {\n  return new L.Filter.BBox(geometryField, bbox, crs);\n};\n\nL.Filter.GmlObjectID = L.Filter.Abstract.extend({\n  tagName: 'ogc:GmlObjectId',\n\n  initialize: function (id) {\n    this.attributes =  { 'gml:id': id };\n  },\n\n  buildFilterContent: function() {\n  }\n});\n\nL.Filter.gmlobjectid = function(id) {\n  return new L.Filter.GmlObjectID(id);\n};\n\nL.Filter.BinaryOperator = L.Filter.Abstract.extend({\n  initialize: function (firstValue, secondValue) {\n    this.firstValue = firstValue;\n    this.secondValue = secondValue;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyElement(this.firstValue));\n    filterElement.appendChild(L.Filter.literalElement(this.secondValue));\n  }\n});\n\nL.Filter.Add = L.Filter.BinaryOperator.extend({\n  tagName: 'Add'\n});\n\nL.Filter.add = function(a, b) {\n  return new L.Filter.Add(a, b);\n};\n\nL.Filter.Sub = L.Filter.BinaryOperator.extend({\n  tagName: 'Sub'\n});\n\nL.Filter.sub = function(a, b) {\n  return new L.Filter.Sub(a, b);\n};\n\nL.Filter.Mul = L.Filter.BinaryOperator.extend({\n  tagName: 'Mul'\n});\n\nL.Filter.mul = function(a, b) {\n  return new L.Filter.Mul(a, b);\n};\n\nL.Filter.Div = L.Filter.BinaryOperator.extend({\n  tagName: 'Div'\n});\n\nL.Filter.div = function(a, b) {\n  return new L.Filter.Div(a, b);\n};\n\nL.Filter.BinaryComparison = L.Filter.BinaryOperator.extend({\n  matchCase: false,\n\n  initialize: function(firstValue, secondValue, matchCase) {\n    L.Filter.BinaryOperator.prototype.initialize.call(this, firstValue, secondValue);\n    this.attributes = { matchCase: !!matchCase };\n  }\n});\n\nL.Filter.EQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsEqualTo'\n});\n\nL.Filter.eq = function(firstValue, secondValue) {\n  return new L.Filter.EQ(firstValue, secondValue);\n};\n\nL.Filter.NotEQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsNotEqualTo'\n});\n\nL.Filter.neq = function(firstValue, secondValue) {\n  return new L.Filter.NotEQ(firstValue, secondValue);\n};\n\nL.Filter.LT = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsLessThan'\n});\n\nL.Filter.lt = function(firstValue, secondValue) {\n  return new L.Filter.LT(firstValue, secondValue);\n};\n\nL.Filter.GT = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsGreaterThan'\n});\n\nL.Filter.gt = function(firstValue, secondValue) {\n  return new L.Filter.GT(firstValue, secondValue);\n};\n\nL.Filter.LEQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsLessThanOrEqualTo'\n});\n\nL.Filter.leq = function(firstValue, secondValue) {\n  return new L.Filter.LEQ(firstValue, secondValue);\n};\n\nL.Filter.GEQ = L.Filter.BinaryComparison.extend({\n  tagName: 'ogc:PropertyIsGreaterThanOrEqualTo'\n});\n\nL.Filter.geq = function(firstValue, secondValue) {\n  return new L.Filter.GEQ(firstValue, secondValue);\n};\n\nL.Filter.Like = L.Filter.Abstract.extend({\n  tagName: 'ogc:PropertyIsLike',\n\n  wildCard: '*',\n  singleChar: '#',\n  escapeChar: '!',\n  matchCase: true,\n\n  initialize: function (name, val, attributes) {\n    this.name = name;\n    this.val = val;\n    var defaultAttributes = { wildCard: this.wildCard, singleChar: this.singleChar, escapeChar: this.escapeChar, matchCase: this.matchCase };\n    this.attributes = L.extend(defaultAttributes, attributes || {});\n  },\n\n  buildFilterContent: function (filterElement) {\n    var nameElement = L.Filter.propertyName(this.name);\n    var valueElement = L.Filter.literal(this.val);\n    filterElement.appendChild(nameElement);\n    filterElement.appendChild(valueElement);\n    return filterElement;\n  }\n});\n\nL.Filter.like = function(name, val, attributes) {\n  return new L.Filter.Like(name, val, attributes);\n};\n\nL.Filter.IsNull = L.Filter.Abstract.extend({\n  tagName: 'ogc:PropertyIsNull',\n\n  initialize: function (propertyName) {\n    this.propertyName = propertyName;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyName(this.propertyName));\n  }\n});\n\nL.Filter.isnull = function(propertyName) {\n  return new L.Filter.IsNull(propertyName);\n};\n\nL.Filter.IsBetween = L.Filter.Abstract.extend({\n  tagName: 'ogc:PropertyIsBetween',\n\n  initialize: function (property, lowerBoundary, upperBoundary) {\n    this.property = property;\n    this.lowerBoundary = lowerBoundary;\n    this.upperBoundary = upperBoundary;\n  },\n\n  buildFilterContent: function (filterElement) {\n    filterElement.appendChild(L.Filter.propertyElement(this.property));\n\n    var lowerBoundaryElement = L.XmlUtil.createElementNS('ogc:LowerBoundary');\n    lowerBoundaryElement.appendChild(L.Filter.literalElement(this.lowerBoundary));\n\n    filterElement.appendChild(lowerBoundaryElement);\n\n    var upperBoundaryElement = L.XmlUtil.createElementNS('ogc:UpperBoundary');\n    upperBoundaryElement.appendChild(L.Filter.literalElement(this.upperBoundary));\n\n    filterElement.appendChild(upperBoundaryElement);\n  }\n});\n\nL.Filter.isbetween = function(property, lowerBoundary, upperBoundary) {\n  return new L.Filter.IsBetween(property, lowerBoundary, upperBoundary);\n};\n\nL.Filter.BinaryLogic = L.Filter.Abstract.extend({\n  filters: null,\n\n  initialize: function () {\n    var filters = [];\n    for (var i = 0; i < arguments.length; i++) {\n      filters.push(arguments[i]);\n    }\n\n    this.filters = filters;\n  },\n\n  buildFilterContent: function (filterElement) {\n    this.filters.forEach(function(filter) {\n      filterElement.appendChild(L.Filter.element(filter));\n    });\n  }\n});\n\nL.Filter.And = L.Filter.BinaryLogic.extend({\n  tagName: 'And'\n});\n\nL.Filter.and = function() {\n  return new (Function.prototype.bind.apply(L.Filter.And, arguments))();\n};\n\nL.Filter.Or = L.Filter.BinaryLogic.extend({\n  tagName: 'Or'\n});\n\nL.Filter.or = function() {\n  return new (Function.prototype.bind.apply(L.Filter.Or, arguments))();\n};\n\nL.Filter.Not = L.Filter.Abstract.extend({\n  tagName: 'Not',\n\n  initialize: function(filter) {\n    this.filter = filter;\n  },\n\n  buildFilterContent: function(filterElement) {\n    filterElement.appendChild(L.Filter.element(this.filter));\n  }\n});\n\nL.Filter.not = function(filter) {\n  return new L.Filter.Not(filter);\n};\n\nL.Filter.Function = L.Filter.Abstract.extend({\n  tagName: 'Function',\n\n  initialize: function () {\n    var functionName = arguments[0];\n    this.attributes = { name: functionName };\n    var expressions = [];\n    for (var i = 1; i < arguments.length; i++) {\n      expressions.push(arguments[i]);\n    }\n\n    this.expressions = expressions;\n  },\n\n  buildFilterContent: function (filterElement) {\n    var firstArgument = this.expressions[0];\n    filterElement.appendChild(L.Filter.propertyElement(firstArgument));\n\n    for (var i = 1; i < this.expressions.length; i++) {\n      var functionArgument = this.expressions[i];\n      filterElement.appendChild(L.Filter.literalElement(functionArgument));\n    }\n  }\n});\n\nL.Filter.function = function() {\n  return new (Function.prototype.bind.apply(L.Filter.Function, arguments))();\n};\n\nL.Format = {};\n\nL.Format.Scheme = L.Class.extend({\n  options: {\n    geometryField: 'Shape',\n  },\n\n  initialize: function (options) {\n    L.setOptions(this, options);\n  },\n\n  parse: function (element) {\n    var featureType = new L.GML.FeatureType({\n      geometryField: this.options.geometryField\n    });\n    var complexTypeDefinition = element.getElementsByTagNameNS(L.XmlUtil.namespaces.xsd, 'complexType')[0];\n    var properties = complexTypeDefinition.getElementsByTagNameNS(L.XmlUtil.namespaces.xsd, 'sequence')[0];\n    for (var i = 0; i < properties.children.length; i++) {\n      var node = properties.children[i];\n      var propertyAttr = node.attributes.name;\n      if (!propertyAttr) {\n        continue;\n      }\n\n      var propertyName = node.attributes.name.value;\n      var typeAttr = node.attributes.type;\n      if (!typeAttr) {\n        var restriction = node.getElementsByTagNameNS(L.XmlUtil.namespaces.xsd, 'restriction');\n        typeAttr = restriction.attributes.base;\n      }\n\n      if (!typeAttr) {\n        continue;\n      }\n\n      var typeName = typeAttr.value.split(':').pop();\n\n      if (propertyName === this.options.geometryField) {\n        featureType.geometryFields[propertyName] = typeName;\n        continue;\n      }\n\n      featureType.appendField(propertyName, typeName);\n    }\n\n    return featureType;\n  }\n});\n\nL.Format.Base = L.Class.extend({\n\n  /**\n   * @property defaultOptions\n   */\n  defaultOptions: {\n    crs: L.CRS.EPSG3857,\n    coordsToLatLng: function (coords) {\n      return new L.LatLng(coords[1], coords[0], coords[2]);\n    },\n    latLngToCoords: function (latlng) {\n      var coords = [latlng.lng, latlng.lat];\n      if (latlng.alt !== undefined) {\n        coords.push(latlng.alt);\n      }\n      return coords;\n    },\n    geometryField: 'Shape'\n  },\n\n  initialize: function (options) {\n    L.setOptions(this, L.extend({}, this.defaultOptions, options));\n    if (options.crs) {\n      var crs = options.crs;\n      this.options.coordsToLatLng = function (coords) {\n        var point = L.point(coords[0], coords[1]);\n        var ll = crs.projection.unproject(point);\n        if (coords[2]) {\n          ll.alt = coords[2];\n        }\n        return ll;\n      };\n      this.options.latLngToCoords = function (ll) {\n        var latLng = L.latLng(ll);\n        return crs.projection.project(latLng);\n      };\n    }\n  },\n\n  /**\n   * Generate feature description by response from DescribeFeatureType\n   *\n   * @method setFeatureDescription\n   * @param {Element} featureInfo response from WFS DescribeFeatureType request\n   */\n  setFeatureDescription: function (featureInfo) {\n    this.namespaceUri = featureInfo.attributes.targetNamespace.value;\n    var schemeParser = new L.Format.Scheme({\n      geometryField: this.options.geometryField\n    });\n    this.featureType = schemeParser.parse(featureInfo);\n  },\n\n  responseToLayers: function() {\n    throw \"responseToLayers is abstract and should be implemented\";\n  }\n});\n\nL.Format.GeoJSON = L.Format.Base.extend({\n\n  outputFormat: 'application/json',\n\n  /**\n   * Convert raw data to leaflet layers array\n   *\n   * @method responseToLayers\n   * @param {string} rawData\n   * @return {Array} Array of leaflet layers\n   */\n  responseToLayers: function (rawData) {\n    var layers = [];\n    var geoJson = JSON.parse(rawData);\n\n    for (var i = 0; i < geoJson.features.length; i++) {\n      var layer = this.processFeature(geoJson.features[i]);\n      if (layer) {\n        layers.push(layer);\n      }\n    }\n\n    return layers;\n  },\n\n  /**\n   * Create layer and set its properties from geoJson feature\n   *\n   * @method processFeature\n   * @param {json} feature\n   * @return {Layer} leaflet layer with \"feature\" property with feature fields values\n   * @private\n   */\n  processFeature: function (feature) {\n    var layer = this.generateLayer(feature);\n    if (!layer) {\n      return null;\n    }\n\n    layer.feature = feature;\n    return layer;\n  },\n\n  /**\n   * Create leaflet layer from geoJson feature\n   *\n   * @method generateLayer\n   * @param {json} feature\n   * @return {Layer} leaflet layer\n   * @private\n   */\n  generateLayer: function (feature) {\n    var layer = L.GeoJSON.geometryToLayer(feature, this.options || null);\n    if (!layer) {\n      console.log(\n        'Geometry field doesn\\' exist inside received feature: \\'' + feature + '\\', ' +\n        'so feature will be skipped and won\\'t be converted into leaflet layer');\n\n        return null;\n    }\n\n    return layer;\n  }\n});\n\nL.GML = L.GML || {};\n\nL.GML.ParserContainerMixin = {\n\n  parsers: {},\n\n  initializeParserContainer: function () {\n    this.parsers = {};\n  },\n\n  appendParser: function (parser) {\n    this.parsers[parser.elementTag] = parser;\n  },\n\n  parseElement: function (element, options) {\n    var parser = this.parsers[element.tagName];\n    if (!parser) throw('unknown child element ' + element.tagName);\n\n    return parser.parse(element, options);\n  }\n};\n\nL.GML.Element = L.Class.extend({\n  elementTag: '',\n  parse: function () {\n    throw('not implemented parse function in parser for ' + this.elementTag);\n  }\n});\n\nL.GML.Geometry = L.GML.Element.extend({\n\n  /**\n   * Returns new object where options properties merged with element specific values\n   *\n   * @method elementOptions\n   * @param {Element} element\n   * @param {Object} options\n   */\n  elementOptions: function(element, options) {\n    var result = L.extend({}, options);\n    var dimension = element.getAttribute('srsDimension');\n    if(dimension) {\n      result.dimension = parseInt(dimension);\n    }\n\n    return result;\n  }\n});\n\nL.GML.Coordinates = L.GML.Element.extend({\n\n  defaultSeparator: {\n    ds: '.', //decimal separator\n    cs: ',', // component separator\n    ts: ' ' // tuple separator\n  },\n\n  elementTag: 'gml:coordinates',\n\n  parse: function (element) {\n\n    var ds = this.defaultSeparator.ds;\n    if (element.attributes.decimal) {\n      ds = element.attributes.decimal.value;\n    }\n\n    var cs = this.defaultSeparator.cs;\n    if (element.attributes.cs) {\n      cs = element.attributes.cs.value;\n    }\n\n    var ts = this.defaultSeparator.ts;\n    if (element.attributes.ts) {\n      ts = element.attributes.ts.value;\n    }\n\n    var result = [];\n    var coords = element.textContent.split(ts);\n\n    var mapFunction = function (coord) {\n      if (ds !== '.') {\n        coord = coord.replace(ds, '.');\n      }\n\n      return parseFloat(coord);\n    };\n\n    for (var i = 0; i < coords.length; i++) {\n      result.push(coords[i].split(cs).map(mapFunction));\n    }\n\n    if (result.length === 1) {\n      return result[0];\n    }\n\n    return result;\n  }\n});\n\nL.GML.Pos = L.GML.Element.extend({\n\n  elementTag: 'gml:pos',\n\n  parse: function (element) {\n    return element.textContent.split(' ').map(function (coord) {\n      return parseFloat(coord);\n    });\n  }\n});\n\nL.GML.PosList = L.GML.Element.extend({\n  statics: {\n    DIM: 2\n  },\n\n  elementTag: 'gml:posList',\n\n  parse: function (element, options) {\n    var result = [];\n    options = options || {};\n    var dim = options.dimension || L.GML.PosList.DIM;\n    var coords = element.textContent.split(' ');\n    for (var i = 0; i < coords.length; i += dim) {\n      var coord = [];\n      for (var j = i; j < i + dim; j++) {\n        coord.push(parseFloat(coords[j]));\n      }\n      result.push(coord);\n    }\n\n    return result;\n  }\n});\n\nL.GML.PointNode = L.GML.Geometry.extend({\n  includes: L.GML.ParserContainerMixin,\n\n  elementTag: 'gml:Point',\n\n  initialize: function () {\n    this.initializeParserContainer();\n    this.appendParser(new L.GML.Pos());\n    this.appendParser(new L.GML.Coordinates());\n  },\n\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    return this.parseElement(element.firstElementChild, options);\n  }\n});\n\nL.GML.PointSequence = L.GML.Geometry.extend({\n  includes: L.GML.ParserContainerMixin,\n\n  initialize: function () {\n    this.initializeParserContainer();\n    this.appendParser(new L.GML.Pos());\n    this.appendParser(new L.GML.PosList());\n    this.appendParser(new L.GML.Coordinates());\n    this.appendParser(new L.GML.PointNode());\n  },\n\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    var firstChild = element.firstElementChild;\n    var coords = [];\n    var tagName = firstChild.tagName;\n    if (tagName === 'gml:pos' || tagName === 'gml:Point') {\n      var childParser = this.parsers[tagName];\n      var elements = element.getElementsByTagNameNS(L.XmlUtil.namespaces.gml, tagName.split(':').pop());\n      for (var i = 0; i < elements.length; i++) {\n        coords.push(childParser.parse(elements[i], options));\n      }\n    }\n    else {\n      coords = this.parseElement(firstChild, options);\n    }\n\n    return coords;\n  }\n});\n\nL.GML.LinearRing = L.GML.PointSequence.extend({\n\n  elementTag: 'gml:LinearRing',\n\n  /**\n   * Parse element into array of coordinates\n   *\n   * @method parse\n   * @param {Element} element\n   * @param {Object} options\n   * @return {Array} array of L.Point\n   */\n  parse: function (element, options) {\n    var coords = L.GML.PointSequence.prototype.parse.call(this, element, options);\n\n    // for leaflet polygons its not recommended insert additional last point equal to the first one,\n    // but GML linearRing contains it\n    coords.pop();\n    return coords;\n  }\n});\n\nL.GML.LineStringNode = L.GML.PointSequence.extend({\n  elementTag: 'gml:LineString'\n});\n\nL.GML.PolygonNode = L.GML.Geometry.extend({\n\n  elementTag: 'gml:Polygon',\n\n  initialize: function () {\n    this.linearRingParser = new L.GML.LinearRing();\n  },\n\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    var coords = [];\n    for (var i = 0; i < element.children.length; i++) {\n\n      // there can be exterior and interior, by GML standard but for leaflet its not significant\n      var child = element.children[i];\n      coords.push(this.linearRingParser.parse(child.firstElementChild, options));\n    }\n\n    return coords;\n  }\n});\n\nL.GML.CoordsToLatLngMixin = {\n  transform: function (coordinates, options) {\n    if (Array.isArray(coordinates[0])) {\n      var latLngs = [];\n      for (var i = 0; i < coordinates.length; i++) {\n        latLngs.push(this.transform(coordinates[i], options));\n      }\n\n      return latLngs;\n    }\n\n    return options.coordsToLatLng(coordinates);\n  }\n};\n\nL.GML.Point = L.GML.PointNode.extend({\n  includes: L.GML.CoordsToLatLngMixin,\n\n  parse: function (element, options) {\n    var coords = L.GML.PointNode.prototype.parse.call(this, element, options);\n    var layer = new L.Marker();\n    layer.setLatLng(this.transform(coords, options));\n    return layer;\n  }\n});\n\nL.GML.LineString = L.GML.LineStringNode.extend({\n\n  includes: L.GML.CoordsToLatLngMixin,\n\n  /**\n   * Get layer from passed element\n   *\n   * @method parse\n   * @param {Element} element\n   * @param {Object} options\n   * @return {L.Layer} polyline layer\n   */\n  parse: function (element, options) {\n    var layer = new L.Polyline([]);\n    var coordinates = L.GML.LineStringNode.prototype.parse.call(this, element);\n    layer.setLatLngs(this.transform(coordinates, options));\n    return layer;\n  }\n});\n\nL.GML.Polygon = L.GML.PolygonNode.extend({\n\n  includes: L.GML.CoordsToLatLngMixin,\n\n  parse: function (element, options) {\n    var layer = new L.Polygon([]);\n    var coordinates = L.GML.PolygonNode.prototype.parse.call(this, element, options);\n    layer.setLatLngs(this.transform(coordinates, options));\n    return layer;\n  }\n});\n\nL.GML.MultiGeometry = L.GML.Geometry.extend({\n  includes: [L.GML.ParserContainerMixin, L.GML.CoordsToLatLngMixin],\n\n  initialize: function () {\n    this.initializeParserContainer();\n  },\n\n  /**\n   * Convert element to array of geometry objects\n   *\n   * @method parse\n   * @param {Element} element\n   * @param {options}\n   * @return {Array} array of geometry objects\n   */\n  parse: function (element, options) {\n    options = this.elementOptions(element, options);\n    var childObjects = [];\n    for (var i = 0; i < element.children.length; i++) {\n      var geometryMember = element.children[i];\n\n      for (var j = 0; j < geometryMember.children.length; j++) {\n        var singleGeometry = geometryMember.children[j];\n        childObjects.push(this.parseElement(singleGeometry, options));\n      }\n    }\n\n    return this.transform(childObjects, options);\n  }\n});\n\nL.GML.AbstractMultiPolyline = L.GML.MultiGeometry.extend({\n\n  initialize: function () {\n    L.GML.MultiGeometry.prototype.initialize.call(this);\n    this.appendParser(new L.GML.LineStringNode());\n  },\n\n  parse: function (element, options) {\n    var latLngs = L.GML.MultiGeometry.prototype.parse.call(this, element, options);\n    var layer = new L.Polyline([]);\n    layer.setLatLngs(latLngs);\n    return layer;\n  }\n});\n\nL.GML.AbstractMultiPolygon = L.GML.MultiGeometry.extend({\n\n  initialize: function () {\n    L.GML.MultiGeometry.prototype.initialize.call(this);\n    this.appendParser(new L.GML.PolygonNode());\n  },\n\n  parse: function (element, options) {\n    var latLngs = L.GML.MultiGeometry.prototype.parse.call(this, element, options);\n    var layer = new L.Polygon([]);\n    layer.setLatLngs(latLngs);\n    return layer;\n  }\n});\n\nL.GML.MultiLineString = L.GML.AbstractMultiPolyline.extend({\n  elementTag: 'gml:MultiLineString'\n});\n\nL.GML.MultiCurve = L.GML.AbstractMultiPolyline.extend({\n  elementTag: 'gml:MultiCurve'\n});\n\nL.GML.MultiPolygon = L.GML.AbstractMultiPolygon.extend({\n  elementTag: 'gml:MultiPolygon'\n});\n\nL.GML.MultiSurface = L.GML.AbstractMultiPolygon.extend({\n  elementTag: 'gml:MultiSurface'\n});\n\nL.GML.MultiPoint = L.GML.MultiGeometry.extend({\n  elementTag: 'gml:MultiPoint',\n\n  initialize: function () {\n    L.GML.MultiGeometry.prototype.initialize.call(this);\n    this.appendParser(new L.GML.PointNode());\n  },\n\n  parse: function (element, options) {\n    var coordinates = L.GML.MultiGeometry.prototype.parse.call(this, element, options);\n    var multiPoint = new L.FeatureGroup();\n    for (var i = 0; i < coordinates.length; i++) {\n      var point = new L.Marker();\n      point.setLatLng(coordinates[i]);\n      multiPoint.addLayer(point);\n    }\n\n    return multiPoint;\n  }\n});\n\nL.GML.FeatureType = L.Class.extend({\n  options: {\n    geometryField: 'Shape',\n  },\n\n  primitives: [\n    {\n      types: ['byte', 'short', 'int', 'integer', 'long', 'float', 'double', 'decimal'],\n      parse: function (input) {\n        if (input === 0) {\n          return 0;\n        }\n        input = String.prototype.trim.call(input || '');\n        return input === '' ? null : Number(input);\n      },\n      validate: function (parsedValue) {\n        // Invalid number can be detected by isNaN check.\n        return !isNaN(parsedValue);\n      },\n      type: 'number'\n    },\n    {\n      types: ['string'],\n      parse: function (input) {\n        return input;\n      },\n      validate: function (parsedValue) {\n        // Any value is valid for 'string' type.\n        return true;\n      },\n      type: 'string'\n    },\n    {\n      types: ['boolean'],\n      parse: function (input) {\n        input = String.prototype.trim.call(input || '').toLowerCase();\n        return input !== 'false';\n      },\n      validate: function (parsedValue) {\n        // Any value is valid for 'boolean' type if parser parses it like so: input !== 'false'.\n        return true;\n      },\n      type: 'boolean'\n    },\n    {\n      types: ['date', 'time', 'datetime'],\n      parse: function (input) {\n        input = String.prototype.trim.call(input || '');\n        return input === '' ? null : new Date(input);\n      },\n      validate: function (parsedValue) {\n        // Invalid date also can be detected by isNaN check.\n        return !isNaN(parsedValue);\n      },\n      type: 'date'\n    }\n  ],\n\n  initialize: function (options) {\n    L.setOptions(this, options);\n\n    this.fields = {};\n    this.fieldValidators = {};\n    this.fieldTypes = {};\n    this.geometryFields = {};\n  },\n\n  appendField: function (name, type) {\n    var that = this;\n    type = String.prototype.toLowerCase.call(type || '');\n\n    this.primitives.forEach(function (primitive) {\n      if (primitive.types.indexOf(type) !== -1) {\n        that.fields[name] = primitive.parse;\n        that.fieldValidators[name] = primitive.validate;\n        that.fieldTypes[name] = primitive.type;\n      }\n    });\n  },\n\n  parse: function (feature) {\n    var properties = {};\n    for (var i = 0; i < feature.children.length; i++) {\n      var node = feature.children[i];\n      var propertyName = node.tagName.split(':').pop();\n      if (propertyName === this.options.geometryField) {\n        continue;\n      }\n\n      var parseField = this.fields[propertyName];\n      if (!parseField) {\n        this.appendField(propertyName, 'string');\n        parseField = this.fields[propertyName];\n      }\n\n      properties[propertyName] = parseField(node.textContent);\n    }\n\n    return {\n      type: 'Feature',\n      properties: properties,\n      id: feature.attributes['gml:id'].value\n    };\n  }\n});\n\nL.Format.GML = L.Format.Base.extend({\n\n  includes: L.GML.ParserContainerMixin,\n\n  outputFormat: 'text/xml; subtype=gml/3.1.1',\n\n  initialize: function (options) {\n    L.Format.Base.prototype.initialize.call(this, options);\n    this.initializeParserContainer();\n    this.appendParser(new L.GML.Point());\n    this.appendParser(new L.GML.LineString());\n    this.appendParser(new L.GML.Polygon());\n    this.appendParser(new L.GML.MultiLineString());\n    this.appendParser(new L.GML.MultiPolygon());\n    this.appendParser(new L.GML.MultiCurve());\n    this.appendParser(new L.GML.MultiSurface());\n    this.appendParser(new L.GML.MultiPoint());\n  },\n\n  /**\n   * Convert raw data to leaflet layers array\n   *\n   * @method responseToLayers\n   * @param {string} rawData\n   * @return {Array} Array of leaflet layers\n   */\n  responseToLayers: function (rawData) {\n    var layers = [];\n    var xmlDoc = L.XmlUtil.parseXml(rawData);\n    var featureCollection = xmlDoc.documentElement;\n    var featureMemberNodes = featureCollection.getElementsByTagNameNS(L.XmlUtil.namespaces.gml, 'featureMember');\n    for (var i = 0; i < featureMemberNodes.length; i++) {\n      var feature = featureMemberNodes[i].firstElementChild;\n      var featureAsLayer = this.processFeature(feature);\n      if (featureAsLayer) {\n        layers.push(featureAsLayer);\n      }\n    }\n\n    var featureMembersNode = featureCollection.getElementsByTagNameNS(L.XmlUtil.namespaces.gml, 'featureMembers');\n    if (featureMembersNode.length > 0) {\n      var features = featureMembersNode[0].children;\n      for (var j = 0; j < features.length; j++) {\n        var node = features[j];\n        var nodeAsLayer = this.processFeature(node);\n        if (nodeAsLayer) {\n          layers.push(nodeAsLayer);\n        }\n      }\n    }\n\n    return layers;\n  },\n\n  /**\n   * Create layer and set its properties from xml feature element\n   *\n   * @method processFeature\n   * @param {Element} feature\n   * @return {Layer} leaflet layer with \"feature\" property with feature fields values\n   * @private\n   */\n  processFeature: function (feature) {\n    var layer = this.generateLayer(feature);\n    if (!layer) {\n      return null;\n    }\n\n    layer.feature = this.featureType.parse(feature);\n    return layer;\n  },\n\n  /**\n   * Create leaflet layer from xml feature element\n   *\n   * @method generateLayer\n   * @param {Element} feature\n   * @return {Layer} leaflet layer\n   * @private\n   */\n  generateLayer: function (feature) {\n    var geometryField = feature.getElementsByTagNameNS(this.namespaceUri, this.options.geometryField)[0];\n    if (!geometryField) {\n      console.log(\n        'Geometry field \\'' + this.options.geometryField + '\\' doesn\\' exist inside received feature: \\'' + feature.innerHTML + '\\', ' +\n        'so feature will be skipped and won\\'t be converted into leaflet layer');\n\n      return null;\n    }\n\n    return this.parseElement(geometryField.firstElementChild, this.options);\n  }\n});\n\nL.Util.project = function (crs, latlngs) {\n  if (L.Util.isArray(latlngs)) {\n    var result = [];\n    latlngs.forEach(function (latlng) {\n      result.push(L.Util.project(crs, latlng));\n    });\n\n    return result;\n  } else {\n    return crs.projection.project(latlngs);\n  }\n};\n\n// 1.0.1 <=> 1.1.0 <=> 1.2.0 compatibility.\nL.Util.isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat;\n\nL.GmlUtil = {\n\n  /**\n   * Create gml:pos Element with passed coordinates\n   *\n   * @method posNode\n   * @param {L.Point} coord\n   * @return {Element} gml:pos\n   */\n  posNode: function (coord) {\n    return L.XmlUtil.createElementNS('gml:pos', { srsDimension: 2 }, { value: coord.x + ' ' + coord.y });\n  },\n\n  /**\n   * Create gml:posList Element from passed coordinates\n   *\n   * @method posListNode\n   * @param {Array} coords Array of L.Point that should be represent as GML\n   * @param {boolean} close Should posList be closed, uses when need do polygon\n   * @return {Element} gml:posList Element\n   */\n  posListNode: function (coords, close) {\n    var localcoords = [];\n    coords.forEach(function (coord) {\n      localcoords.push(coord.x + ' ' + coord.y);\n    });\n    if (close && coords.length > 0) {\n      var coord = coords[0];\n      localcoords.push(coord.x + ' ' + coord.y);\n    }\n\n    var posList = localcoords.join(' ');\n    return L.XmlUtil.createElementNS('gml:posList', {}, { value: posList });\n  }\n};\n\nL.CircleMarker.include({\n  toGml: function(crs) {\n    var node = L.XmlUtil.createElementNS('gml:Point', {srsName: crs.code});\n    node.appendChild(L.GmlUtil.posNode(L.Util.project(crs, this.getLatLng())));\n    return node;\n  }\n});\n\nL.LatLngBounds.prototype.toGml = function (crs) {\n  var projectedSW = crs.project(this.getSouthWest());\n  var projectedNE = crs.project(this.getNorthEast());\n\n  var envelopeElement = L.XmlUtil.createElementNS('gml:Envelope', { srsName: crs.code });\n  envelopeElement.appendChild(L.XmlUtil.createElementNS('gml:lowerCorner', {}, { value: projectedSW.x + ' ' + projectedSW.y }));\n  envelopeElement.appendChild(L.XmlUtil.createElementNS('gml:upperCorner', {}, { value: projectedNE.x + ' ' + projectedNE.y }));\n\n  return envelopeElement;\n};\n\nL.Marker.include({\n  toGml: function (crs) {\n    var node = L.XmlUtil.createElementNS('gml:Point', {srsName: crs.code});\n    node.appendChild(L.GmlUtil.posNode(L.Util.project(crs, this.getLatLng())));\n    return node;\n  }\n});\n\nL.Polygon.include({\n  toGml: function (crs, forceMulti) {\n    var polygons = this.getLatLngs();\n    var gmlPolygons = [];\n\n    for (var i = 0; i < polygons.length; i++) {\n      var polygonCoordinates = polygons[i];\n      var flat = L.Util.isFlat(polygonCoordinates);\n      var node = L.XmlUtil.createElementNS('gml:Polygon', {srsName: crs.code, srsDimension: 2});\n      node.appendChild(L.XmlUtil.createElementNS('gml:exterior'))\n        .appendChild(L.XmlUtil.createElementNS('gml:LinearRing', {srsDimension: 2}))\n        .appendChild(L.GmlUtil.posListNode(L.Util.project(crs, flat ? polygonCoordinates : polygonCoordinates[0]), true));\n\n      if (!flat) {\n        for (var hole = 1; hole < polygonCoordinates.length; hole++) {\n          node.appendChild(L.XmlUtil.createElementNS('gml:interior'))\n            .appendChild(L.XmlUtil.createElementNS('gml:LinearRing', {srsDimension: 2}))\n            .appendChild(L.GmlUtil.posListNode(L.Util.project(crs, polygonCoordinates[hole]), true));\n        }\n      }\n\n      gmlPolygons.push(node);\n    }\n\n    if (gmlPolygons.length === 1 && !forceMulti) return gmlPolygons[0];\n\n    // else make multipolygon\n    var multi = L.XmlUtil.createElementNS('gml:MultiSurface', {srsName: crs.code, srsDimension: 2});\n    var collection = multi.appendChild(L.XmlUtil.createElementNS('gml:surfaceMembers'));\n    for (var p = 0; p < gmlPolygons.length; p++) {\n      collection.appendChild(gmlPolygons[p]);\n    }\n\n    return multi;\n  }\n});\n\nL.Polyline.include({\n  _lineStringNode: function (crs, latlngs) {\n    var node = L.XmlUtil.createElementNS('gml:LineString', {srsName: crs.code, srsDimension: 2});\n    node.appendChild(L.GmlUtil.posListNode(L.Util.project(crs, latlngs), false));\n    return node;\n  },\n\n  toGml: function (crs, forceMulti) {\n    var latLngs = this.getLatLngs();\n    var gmlElements = [];\n\n    if (L.Util.isFlat(latLngs)) {\n       gmlElements.push(this._lineStringNode(crs, latLngs));\n    } else {\n      for (var i = 0; i < latLngs.length; i++) {\n        gmlElements.push(this._lineStringNode(crs, latLngs[i]));\n      }\n    }\n\n    if(gmlElements.length === 1 && !forceMulti) {\n      return gmlElements[0];\n    }\n\n    var multi = L.XmlUtil.createElementNS('gml:MultiCurve', {srsName: crs.code, srsDimension: 2});\n    var collection = multi.appendChild(L.XmlUtil.createElementNS('gml:curveMembers'));\n    for (var lines = 0; lines < gmlElements.length; lines++) {\n      collection.appendChild(gmlElements[lines]);\n    }\n\n    return multi;\n  }\n});\n\nvar PropertiesMixin = {\n  setProperties: function (obj) {\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        this.feature.properties[i] = obj[i];\n      }\n    }\n  },\n  getProperty: function (field) {\n    return this.feature.properties[field];\n  },\n  deleteProperties: function (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (this.feature.properties.hasOwnProperty(arr[i])) {\n        delete this.feature.properties[arr[i]];\n      }\n    }\n  }\n};\nL.Marker.include(PropertiesMixin);\nL.Path.include(PropertiesMixin);\n\nL.WFS = L.FeatureGroup.extend({\n\n  _capabilities: null,\n\n  _boundingBox: null,\n\n  options: {\n    crs: L.CRS.EPSG3857,\n    showExisting: true,\n    geometryField: 'Shape',\n    url: '',\n    version: '1.1.0',\n    typeNS: '',\n    typeName: '',\n    typeNSName: '',\n    maxFeatures: null,\n    filter: null,\n    opacity: 1,\n    fillOpacity: 1,\n    style: {\n      color: 'black',\n      weight: 1,\n      opacity: 1,\n      fillOpacity: 1\n    },\n    namespaceUri: ''\n  },\n\n  state: {},\n\n  initialize: function (options, readFormat) {\n    L.setOptions(this, options);\n\n    this.state = {\n      exist: 'exist'\n    };\n\n    this._layers = {};\n\n    this.readFormat = readFormat || new L.Format.GML({\n      crs: this.options.crs,\n      geometryField: this.options.geometryField\n    });\n\n    this.options.typeNSName = this.namespaceName(this.options.typeName);\n    this.options.srsName = this.options.crs.code;\n\n    this._updateOpacity();\n\n    var that = this;\n    this.describeFeatureType(function () {\n      if (that.options.showExisting) {\n        that.loadFeatures(that.options.filter);\n      }\n    }, function (errorMessage) {\n      that.fire('error', {\n        error: new Error(errorMessage)\n      });\n    });\n  },\n\n  namespaceName: function (name) {\n    return this.options.typeNS + ':' + name;\n  },\n\n  describeFeatureType: function (successCallback, errorCallback) {\n    var requestData = L.XmlUtil.createElementNS('wfs:DescribeFeatureType', {\n      service: 'WFS',\n      version: this.options.version\n    });\n    requestData.appendChild(L.XmlUtil.createElementNS('TypeName', {}, {\n      value: this.options.typeNSName\n    }));\n\n    var that = this;\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(requestData),\n      headers: this.options.headers || {},\n      success: function (data) {\n        // If some exception occur, WFS-service can response successfully, but with ExceptionReport,\n        // and such situation must be handled.\n        var exceptionReport = L.XmlUtil.parseOwsExceptionReport(data);\n        if (exceptionReport) {\n          if (typeof (errorCallback) === 'function') {\n            errorCallback(exceptionReport.message);\n          }\n\n          return;\n        }\n\n        var xmldoc = L.XmlUtil.parseXml(data);\n        var featureInfo = xmldoc.documentElement;\n        that.readFormat.setFeatureDescription(featureInfo);\n        that.options.namespaceUri = featureInfo.attributes.targetNamespace.value;\n        if (typeof (successCallback) === 'function') {\n          successCallback();\n        }\n      },\n      error: function (errorMessage) {\n        if (typeof (errorCallback) === 'function') {\n          errorCallback(errorMessage);\n        }\n      }\n    });\n  },\n\n  getFeature: function (filter) {\n    var request = L.XmlUtil.createElementNS('wfs:GetFeature', {\n      service: 'WFS',\n      version: this.options.version,\n      maxFeatures: this.options.maxFeatures,\n      outputFormat: this.readFormat.outputFormat\n    });\n\n    var query = request.appendChild(L.XmlUtil.createElementNS('wfs:Query', {\n      typeName: this.options.typeNSName,\n      srsName: this.options.srsName\n    }));\n\n    if (filter) {\n      query.appendChild(L.filter(filter));\n    }\n\n    return request;\n  },\n\n  loadFeatures: function (filter) {\n    var that = this;\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(that.getFeature(filter)),\n      headers: this.options.headers || {},\n      success: function (responseText) {\n        // If some exception occur, WFS-service can response successfully, but with ExceptionReport,\n        // and such situation must be handled.\n        var exceptionReport = L.XmlUtil.parseOwsExceptionReport(responseText);\n        if (exceptionReport) {\n          that.fire('error', {\n            error: new Error(exceptionReport.message)\n          });\n\n          return that;\n        }\n\n        // Request was truly successful (without exception report),\n        // so convert response to layers.\n        var layers = that.readFormat.responseToLayers(responseText, {\n          coordsToLatLng: that.options.coordsToLatLng,\n          pointToLayer: that.options.pointToLayer\n        });\n\n        if (typeof that.options.style === \"function\") {\n          layers.forEach(function (element) {\n            element.state = that.state.exist;\n            if (element.setStyle) {\n              element.setStyle(that.options.style(element));\n            }\n            that.addLayer(element);\n          });\n        } else {\n          layers.forEach(function (element) {\n            element.state = that.state.exist;\n            that.addLayer(element);\n          });\n          that.setStyle(that.options.style);\n        }\n\n        that.fire('load', {\n          responseText: responseText\n        });\n\n        return that;\n      },\n      error: function (errorMessage) {\n        that.fire('error', {\n          error: new Error(errorMessage)\n        });\n\n        return that;\n      }\n    });\n  },\n\n  getCapabilities: function (successCallback, errorCallback) {\n    var capabilities = this._capabilities;\n\n    // Check if capabilities were already received & cached.\n    if (capabilities) {\n      if (typeof (successCallback) === 'function') {\n        successCallback(capabilities);\n\n        return;\n      }\n    }\n\n    var requestData = L.XmlUtil.createElementNS('wfs:GetCapabilities', {\n      service: 'WFS',\n      version: this.options.version\n    });\n\n    var that = this;\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(requestData),\n      headers: this.options.headers || {},\n      success: function (data) {\n        // If some exception occur, WFS-service can response successfully, but with ExceptionReport,\n        // and such situation must be handled.\n        var exceptionReport = L.XmlUtil.parseOwsExceptionReport(data);\n        if (exceptionReport) {\n          if (typeof (errorCallback) === 'function') {\n            errorCallback(new Error(exceptionReport.message));\n          }\n\n          return;\n        }\n\n        try {\n          // Request was truly successful (without exception report), parse WFS_Capabilities.\n          capabilities = L.XmlUtil.parseXml(data).documentElement;\n        } catch (error) {\n          // If parsing failed.\n          if (typeof (errorCallback) === 'function') {\n            errorCallback(error);\n          }\n\n          return;\n        }\n\n        // Cache received capabilities.\n        that._capabilities = capabilities;\n\n        if (typeof (successCallback) === 'function') {\n          successCallback(capabilities);\n        }\n      },\n      error: function (errorMessage) {\n        if (typeof (errorCallback) === 'function') {\n          errorCallback(new Error(errorMessage));\n        }\n      }\n    });\n  },\n\n  getBoundingBox: function (successCallback, errorCallback) {\n    var boundingBox = this._boundingBox;\n\n    // Check if bounding box was already received & cached.\n    if (boundingBox) {\n      if (typeof (successCallback) === 'function') {\n        successCallback(boundingBox);\n\n        return;\n      }\n    }\n\n    var that = this;\n    this.getCapabilities(function (capabilities) {\n      var featureTypeListElement = capabilities.getElementsByTagName('FeatureTypeList')[0];\n\n      // Extract all 'FeatureType' nodes to list.\n      var featureTypeList = featureTypeListElement.getElementsByTagName('FeatureType');\n\n      for (var i = 0, len = featureTypeList.length; i < len; i++) {\n        var featureType = featureTypeList[i];\n\n        // Extract current FeatureType's name.\n        var featureTypeNSName = L.XmlUtil.getNodeText(featureType.getElementsByTagName('Name')[0]);\n\n        // Find node with current layer instance's name and namespace.\n        if (featureTypeNSName === that.options.typeNSName) {\n          // The <WGS84BoundingBox> element is used to indicate the edges of an\n          // enclosing rectangle in decimal degrees of latitude and longitude in WGS84.\n          var wgs84BoundingBox = featureType.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'WGS84BoundingBox')[0];\n          var lowerCornerElement = wgs84BoundingBox.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'LowerCorner')[0];\n          var upperCornerElement = wgs84BoundingBox.getElementsByTagNameNS(L.XmlUtil.namespaces.ows, 'UpperCorner')[0];\n\n          // Corner node's inner text format is like '-74.047185 40.679648', Lng and Lat with a space between.\n          var lowerCorner = L.XmlUtil.getNodeText(lowerCornerElement);\n          var upperCorner = L.XmlUtil.getNodeText(upperCornerElement);\n\n          // Extract LngLats and reverse it to LatLngs.\n          var sw = lowerCorner.split(' ').reverse();\n          var ne = upperCorner.split(' ').reverse();\n\n          // Wrap it into LatLngBounds.\n          boundingBox = L.latLngBounds([sw, ne]);\n\n          break;\n        }\n      }\n\n      // Cache received and calculated bounding box.\n      that._boundingBox = boundingBox;\n\n      if (typeof (successCallback) === 'function') {\n        successCallback(boundingBox);\n      }\n    }, function (errorMessage) {\n      if (typeof (errorCallback) === 'function') {\n        errorCallback(new Error(errorMessage));\n      }\n    });\n  },\n\n  setOpacity: function (opacity, fillOpacity) {\n    this.options.opacity = opacity;\n    this.options.fillOpacity = fillOpacity || opacity;\n\n    this._updateOpacity();\n\n    return this;\n  },\n\n  _updateOpacity: function () {\n    var style = L.extend(this.options.style || {}, {\n      opacity: this.options.opacity,\n      fillOpacity: this.options.fillOpacity\n    });\n\n    this.setStyle(style);\n  }\n});\n\nL.wfs = function (options, readFormat) {\n  return new L.WFS(options, readFormat);\n};\n\nL.WFST = L.WFS.extend({\n  options: {\n    forceMulti: false\n  },\n\n  initialize: function (options, readFormat) {\n    L.WFS.prototype.initialize.call(this, options, readFormat);\n    this.state = L.extend(this.state, {\n      insert: 'insertElement',\n      update: 'updateElement',\n      remove: 'removeElement'\n    });\n\n    this.changes = {};\n  },\n\n  addLayer: function (layer) {\n    L.FeatureGroup.prototype.addLayer.call(this, layer);\n    if (!layer.feature) {\n      layer.feature = { properties: {} };\n    }\n\n    if (!layer.state) {\n      layer.state = this.state.insert;\n      var id = this.getLayerId(layer);\n      this.changes[id] = layer;\n    }\n    return this;\n  },\n\n  removeLayer: function (layer) {\n    L.FeatureGroup.prototype.removeLayer.call(this, layer);\n\n    var id = this.getLayerId(layer);\n\n    if (id in this.changes) {\n      var change = this.changes[id];\n      if (change.state === this.state.insert) {\n        delete this.changes[id];\n      }\n      else {\n        change.state = this.state.remove;\n      }\n    }\n    else {\n      layer.state = this.state.remove;\n      this.changes[id] = layer;\n    }\n  },\n\n  editLayer: function (layer) {\n    if (layer.state !== this.state.insert) {\n      layer.state = this.state.update;\n    }\n\n    var id = this.getLayerId(layer);\n    this.changes[id] = layer;\n    return this;\n  },\n\n  save: function () {\n    var transaction = L.XmlUtil.createElementNS('wfs:Transaction', { service: 'WFS', version: this.options.version });\n\n    var inserted = [];\n\n    for (var id in this.changes) {\n      var layer = this.changes[id];\n      var action = this[layer.state](layer);\n      transaction.appendChild(action);\n\n      if (layer.state === this.state.insert) {\n        inserted.push(layer);\n      }\n    }\n\n    var that = this;\n\n    L.Util.request({\n      url: this.options.url,\n      data: L.XmlUtil.serializeXmlDocumentString(transaction),\n      headers: this.options.headers || {},\n      withCredentials: true,\n      success: function (data) {\n        var xmlDoc = L.XmlUtil.parseXml(data);\n        var exception = L.XmlUtil.parseOwsExceptionReport(xmlDoc);\n        if(exception !== null) {\n          that.fire('save:failed', exception);\n          return;\n        }\n\n        var insertResult = L.XmlUtil.evaluate('//wfs:InsertResults/wfs:Feature/ogc:FeatureId/@fid', xmlDoc);\n        var insertedIds = [];\n        var id = insertResult.iterateNext();\n        while (id) {\n          insertedIds.push(new L.Filter.GmlObjectID(id.value));\n          id = insertResult.iterateNext();\n        }\n\n        inserted.forEach(function (layer) {\n          L.FeatureGroup.prototype.removeLayer.call(that, layer);\n        });\n\n        that.once('load', function () {\n          that.fire('save:success');\n          that.changes = {};\n        });\n\n        that.loadFeatures(insertedIds);\n      },\n      error: function (data) {\n        that.fire('save:failed', data);\n      }\n    });\n\n    return this;\n  }\n});\n\nL.wfst = function (options, readFormat) {\n  return new L.WFST(options, readFormat);\n};\n\nL.WFST.include({\n  gmlFeature: function (layer) {\n    var featureNode = L.XmlUtil.createElementNS(this.options.typeNSName, {}, { uri: this.options.namespaceUri });\n    var feature = layer.feature;\n    for (var propertyName in feature.properties) {\n      featureNode.appendChild(this.gmlProperty(propertyName,\n        feature.properties[propertyName]));\n    }\n\n    featureNode.appendChild(\n      this.gmlProperty(\n        this.options.geometryField,\n        layer.toGml(\n          this.options.crs,\n          this.options.forceMulti\n        )\n      )\n    );\n\n    return featureNode;\n  },\n\n  /**\n     Returns element with name as tag and value as innerText or child element\n     ```xml\n     <name>value<name>\n     ```\n\n     or if value is element\n\n     ```xml\n     <name><value /><name>\n     ```\n\n     @method gmlProperty\n     @param {string} name Name of property\n     @param {Object} value Value of property\n     @return {Element} simple property element <name>value<name>\n   */\n  gmlProperty: function (name, value) {\n    var propertyNode = L.XmlUtil.createElementNS(this.namespaceName(name));\n    if (value instanceof Element) {\n      propertyNode.appendChild(value);\n    }\n    else if (value === null || value === undefined || value === '') {\n      L.XmlUtil.setAttributes(propertyNode, { 'xsi:nil': true });\n    } else {\n      propertyNode.appendChild(L.XmlUtil.createTextNode(value));\n    }\n\n    return propertyNode;\n  },\n\n  /**\n    Returns wfs:Property element with passed property name and value:\n    ```xml\n    <wfs:Property>\n      <wfs:Name>%name%</wfs:Name>\n      <wfs:Value>%value%</wfs:Value>\n    </wfs:Property>\n    ```\n\n    @method wfsProperty\n    @param {string} name Property name\n    @param {Object} value Property value, if passed Element object it will be added as child element of value\n    @return {Element}\n   */\n  wfsProperty: function (name, value) {\n    var propertyNode = L.XmlUtil.createElementNS('wfs:Property');\n    propertyNode.appendChild(L.XmlUtil.createElementNS('wfs:Name', {}, { value: name }));\n    var valueNode = L.XmlUtil.createElementNS('wfs:Value');\n    if (value instanceof Element) {\n      valueNode.appendChild(value);\n    }\n    else {\n      valueNode.appendChild(L.XmlUtil.createTextNode(value));\n    }\n\n    propertyNode.appendChild(valueNode);\n\n    return propertyNode;\n  }\n});\n\nL.WFST.include({\n\n  /**\n    Returns wfs:Insert element for passed layer\n\n    @method insertElement\n    @param {Layer} layer\n    @return {Element} wfs:Insert element with layer\n   */\n  insertElement: function (layer) {\n    var node = L.XmlUtil.createElementNS('wfs:Insert');\n    node.appendChild(this.gmlFeature(layer));\n    return node;\n  },\n\n  /**\n    Returns wfs:Update element for specified layer\n\n    @method updateElement\n    @param {Layer} layer\n    @return {Element} wfs:Update element for passed layer properties limited with filter by feature.id\n   */\n  updateElement: function (layer) {\n    var node = L.XmlUtil.createElementNS('wfs:Update', { typeName: this.options.typeNSName });\n    var feature = layer.feature;\n    for (var propertyName in feature.properties) {\n      if (feature.properties.hasOwnProperty(propertyName)) {\n        node.appendChild(this.wfsProperty(propertyName, feature.properties[propertyName]));\n      }\n    }\n\n    node.appendChild(\n      this.wfsProperty(\n        this.namespaceName(this.options.geometryField),\n        layer.toGml(this.options.crs, this.options.forceMulti)\n      )\n    );\n\n    var idFilter = new L.Filter.GmlObjectID(layer.feature.id);\n    node.appendChild(L.filter(idFilter));\n    return node;\n  },\n\n  removeElement: function (layer) {\n    var node = L.XmlUtil.createElementNS('wfs:Delete', { typeName: this.options.typeNSName });\n    var idFilter = new L.Filter.GmlObjectID(layer.feature.id);\n    node.appendChild(L.filter(idFilter));\n    return node;\n  }\n});\n\n\n})(window, document);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/leaflet-wfst/dist/leaflet-wfst.src.js\n// module id = 181\n// module chunks = 5"],"sourceRoot":""}