{"version":3,"sources":["webpack:///plugins/velocityLayer.js","webpack:///webpack/bootstrap 7b19f38a437100774b0e","webpack:///./src/plugins/VelocityLayer.js","webpack:///./src/plugins/velocity/L.VelocityLayer.js","webpack:///./src/plugins/velocity/Windy.js","webpack:///./src/plugins/velocity/L.Control.Velocity.js"],"names":["define","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","156","__webpack_exports__","value","data","options","L","velocityLayer","T","assign","displayValues","displayOptions","velocityType","displayPosition","displayEmptyString","maxVelocity","157","__WEBPACK_IMPORTED_MODULE_0__Windy__","__WEBPACK_IMPORTED_MODULE_1__L_Control_Velocity__","VelocityLayer","Layer","extend","position","emptyString","colorScale","_timer","initialize","_this","this","setOptions","ajax","one","url","f","success","setData","onAdd","map","_canvasLayer","canvasLayer","delegate","addTo","_map","onRemove","_destroyWind","_windy","_clearAndRestart","fire","onDrawLayer","overlay","params","self","_initWindy","clearTimeout","setTimeout","_startWindy","bounds","getBounds","size","getSize","start","x","y","_southWest","lng","lat","_northEast","canvas","_canvas","_context","getContext","classList","add","on","stop","_clearWind","_initMouseHandler","_mouseControl","control","velocity","clearRect","removeControl","removeLayer","158","Windy","builder","grid","date","λ0","φ0","Δλ","Δφ","ni","nj","animationLoop","MIN_VELOCITY_INTENSITY","minVelocity","MAX_VELOCITY_INTENSITY","VELOCITY_SCALE","velocityScale","Math","pow","window","devicePixelRatio","MAX_PARTICLE_AGE","particleAge","PARTICLE_LINE_WIDTH","lineWidth","PARTICLE_MULTIPLIER","particleMultiplier","PARTICLE_REDUCTION","FRAME_RATE","frameRate","FRAME_TIME","defaulColorScale","NULL_WIND_VECTOR","NaN","gridData","bilinearInterpolateVector","g00","g10","g01","g11","rx","ry","a","b","u","v","sqrt","createWindBuilder","uComp","vComp","uData","vData","header","interpolate","createBuilder","scalar","forEach","record","parameterCategory","parameterNumber","buildGrid","callback","lo1","la1","dx","dy","nx","ny","Date","refTime","setHours","getHours","forecastTime","isContinuous","floor","j","row","push","λ","φ","floorMod","fi","ci","fj","cj","isValue","undefined","isMobile","test","navigator","userAgent","distort","projection","scale","wind","windy","distortion","τ","PI","H","hλ","hφ","pλ","project","pφ","k","cos","createField","columns","field","column","round","release","randomize","safetyNet","random","width","height","buildBounds","upperLeft","lowerRight","max","min","ceil","xMax","yMax","deg2rad","deg","rad2deg","ang","invert","mapLonDelta","east","west","worldMapRadius","mapOffsetY","log","sin","south","equatorY","atan","exp","mercY","tan","lon","ymin","ymax","north","xFactor","yFactor","interpolateField","extent","interpolateColumn","coord","isFinite","mapArea","batchInterpolate","now","animate","evolve","buckets","bucket","length","particles","particle","age","xt","yt","colorStyles","indexFor","draw","g","globalCompositeOperation","fillRect","globalAlpha","beginPath","strokeStyle","moveTo","lineTo","stroke","particleCount","fillStyle","then","frame","requestAnimationFrame","delta","mapBounds","Util","cancelAnimFrame","interpolatePoint","159","Control","Velocity","angleConvention","speedUnit","_container","div","DomEvent","disableClickPropagation","_onMouseMove","innerHTML","off","vectorToSpeed","uMs","vMs","unit","velocityAbs","meterSec2kilometerHour","meterSec2Knots","vectorToDegrees","endsWith","abs","velocityDir","atan2","velocityDirToDegrees","meters","e","pos","leafletVelocity","containerPointToLatLng","point","containerPoint","gridValue","htmlOut","isNaN","toFixed","Map","mergeOptions","positionControl","addInitHook","MousePosition","addControl"],"mappings":"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","file":"plugins/velocityLayer.js","sourcesContent":["/*! version:1.4.13 */\ndefine(function() { return /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./dist/dmap/leaflet/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 156);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 156:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__plugins_velocity_L_VelocityLayer__ = __webpack_require__(157);\n/**\r\n * @author gyb(mocheer)\r\n * @email `mocheer@foxmail.com`  \r\n * @since 2018.8.31\r\n */\n\n/**\r\n * \r\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (data, options) {\n  return L.velocityLayer(T.assign({\n    displayValues: true,\n    displayOptions: {\n      velocityType: 'GBR Wind',\n      displayPosition: 'bottomleft',\n      displayEmptyString: 'No wind data'\n      // velocityType: 'Global Wind',\n      // position: 'bottomleft',\n      // emptyString: 'No velocity data',\n      // angleConvention: 'bearingCW',\n      // displayPosition: 'bottomleft',\n      // displayEmptyString: 'No velocity data',\n      // speedUnit: 'kt'\n    },\n    data: data, //grib2.json\n    // OPTIONAL\n    // minVelocity: 0,          // used to align color scale\n    // maxVelocity: 10,         // used to align color scale\n    // velocityScale: 0.005,    // modifier for particle animations, arbitrarily defaults to 0.005\n    // colorScale: []           // define your own array of hex/rgb colors\n    maxVelocity: 10\n  }, options));\n});\n\n/***/ }),\n\n/***/ 157:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Windy__ = __webpack_require__(158);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__L_Control_Velocity__ = __webpack_require__(159);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__L_Control_Velocity___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__L_Control_Velocity__);\n/**\n * @see https://github.com/danwild/leaflet-velocity\n */\n\n\n/**\n * \n */\nL.VelocityLayer = L.Layer.extend({ //L.Class.extend\n\toptions: {\n\t\tdisplayValues: true,\n\t\tdisplayOptions: {\n\t\t\tvelocityType: 'Velocity',\n\t\t\tposition: 'bottomleft',\n\t\t\temptyString: 'No velocity data'\n\t\t},\n\t\tmaxVelocity: 10, // used to align color scale\n\t\tcolorScale: null,\n\t\tdata: null\n\t},\n\t// _map: null,\n\t// _canvasLayer: null,\n\t// _windy: null,\n\t// _context: null,\n\t// _mouseControl: null, //底部风力信息\n\t_timer: 0,\n\n\tinitialize: function initialize(options) {\n\t\tvar _this = this;\n\n\t\tL.setOptions(this, options);\n\t\tthis.ajax = T.one(function (url) {\n\t\t\treturn T.ajax({ f: 'json', url: url, success: function success(data) {\n\t\t\t\t\t_this.setData(data);\n\t\t\t\t} });\n\t\t});\n\t},\n\n\tonAdd: function onAdd(map) {\n\t\t// create canvas, add overlay control\n\t\tthis._canvasLayer = L.canvasLayer().delegate(this);\n\t\tthis._canvasLayer.addTo(map);\n\t\tthis._map = map;\n\t},\n\n\tonRemove: function onRemove(map) {\n\t\tthis._destroyWind();\n\t},\n\n\tsetData: function setData(data) {\n\t\tthis.options.data = data;\n\n\t\tif (this._windy) {\n\t\t\tthis._windy.setData(data);\n\t\t\tthis._clearAndRestart();\n\t\t}\n\n\t\tthis.fire('load');\n\t},\n\n\tonDrawLayer: function onDrawLayer(overlay, params) {\n\t\tvar self = this,\n\t\t    _windy = self._windy,\n\t\t    options = self.options,\n\t\t    _timer = self._timer;\n\n\t\tif (!this._windy) {\n\t\t\tthis._initWindy(self);\n\t\t\treturn;\n\t\t}\n\t\tvar data = options.data,\n\t\t    url = options.url;\n\n\t\tif (!data) {\n\t\t\turl && this.ajax(url);\n\t\t\treturn;\n\t\t}\n\n\t\tif (_timer) clearTimeout(_timer);\n\n\t\tthis._timer = setTimeout(function () {\n\t\t\tself._startWindy();\n\t\t}, 750);\n\t},\n\n\t_startWindy: function _startWindy() {\n\t\tvar bounds = this._map.getBounds();\n\t\tvar size = this._map.getSize();\n\n\t\t// bounds, width, height, extent\n\t\tthis._windy.start([[0, 0], [size.x, size.y]], size.x, size.y, [[bounds._southWest.lng, bounds._southWest.lat], [bounds._northEast.lng, bounds._northEast.lat]]);\n\t},\n\n\t_initWindy: function _initWindy(self) {\n\t\tthis._windy = new __WEBPACK_IMPORTED_MODULE_0__Windy__[\"a\" /* default */](T.assign({ canvas: self._canvasLayer._canvas }, self.options));\n\n\t\t// prepare context global var, start drawing\n\t\tthis._context = this._canvasLayer._canvas.getContext('2d');\n\t\tthis._canvasLayer._canvas.classList.add(\"velocity-overlay\");\n\t\tthis.onDrawLayer();\n\n\t\tthis._map.on('dragstart', self._windy.stop).on('dragend', self._clearAndRestart).on('zoomstart', self._windy.stop).on('zoomend', self._clearAndRestart).on('resize', self._clearWind);\n\n\t\tthis._initMouseHandler();\n\t},\n\n\t_initMouseHandler: function _initMouseHandler() {\n\t\tif (!this._mouseControl && this.options.displayValues) {\n\t\t\tvar options = this.options.displayOptions || {};\n\t\t\toptions['leafletVelocity'] = this;\n\t\t\tthis._mouseControl = L.control.velocity(options).addTo(this._map);\n\t\t}\n\t},\n\n\t_clearAndRestart: function _clearAndRestart() {\n\t\tif (this._context) this._context.clearRect(0, 0, 3000, 3000);\n\t\tif (this._windy) this._startWindy();\n\t},\n\n\t_clearWind: function _clearWind() {\n\t\tif (this._windy) this._windy.stop();\n\t\tif (this._context) this._context.clearRect(0, 0, 3000, 3000);\n\t},\n\n\t_destroyWind: function _destroyWind() {\n\t\tif (this._timer) clearTimeout(this._timer);\n\t\tif (this._windy) this._windy.stop();\n\t\tif (this._context) this._context.clearRect(0, 0, 3000, 3000);\n\t\tif (this._mouseControl) this._map.removeControl(this._mouseControl);\n\t\tthis._mouseControl = null;\n\t\tthis._windy = null;\n\t\tthis._map.removeLayer(this._canvasLayer);\n\t}\n});\n\nL.velocityLayer = function (options) {\n\treturn new L.VelocityLayer(options);\n};\n\n/***/ }),\n\n/***/ 158:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/*  Global class for simulating the movement of particle through a 1km wind grid\n\n credit: All the credit for this work goes to: https://github.com/cambecc for creating the repo:\n https://github.com/cambecc/earth. The majority of this code is directly take nfrom there, since its awesome.\n\n This class takes a canvas element and an array of data (1km GFS from http://www.emc.ncep.noaa.gov/index.php?branch=GFS)\n and then uses a mercator (forward/reverse) projection to correctly map wind vectors in \"map space\".\n\n The \"start\" method takes the bounds of the map at its current extent and starts the whole gridding,\n interpolation and animation process.\n */\n\nvar Windy = function Windy(params) {\n\n\tvar MIN_VELOCITY_INTENSITY = params.minVelocity || 0; // 粒子最小强度的速度\n\tvar MAX_VELOCITY_INTENSITY = params.maxVelocity || 10; // 粒子最大强度的速度\n\tvar VELOCITY_SCALE = (params.velocityScale || 0.005) * (Math.pow(window.devicePixelRatio, 1 / 3) || 1); // 风速因子\n\tvar MAX_PARTICLE_AGE = params.particleAge || 90; // 粒子运动次数\n\tvar PARTICLE_LINE_WIDTH = params.lineWidth || 1; // 粒子宽度\n\tvar PARTICLE_MULTIPLIER = params.particleMultiplier || 1 / 300; // particle count scalar (completely arbitrary--this values looks nice)\n\tvar PARTICLE_REDUCTION = Math.pow(window.devicePixelRatio, 1 / 3) || 1.6; // multiply particle count for mobiles by this amount\n\tvar FRAME_RATE = params.frameRate || 15,\n\t    FRAME_TIME = 1000 / FRAME_RATE; // desired frames per second\n\n\tvar defaulColorScale = [\"rgb(36,104, 180)\", \"rgb(60,157, 194)\", \"rgb(128,205,193 )\", \"rgb(151,218,168 )\", \"rgb(198,231,181)\", \"rgb(238,247,217)\", \"rgb(255,238,159)\", \"rgb(252,217,125)\", \"rgb(255,182,100)\", \"rgb(252,150,75)\", \"rgb(250,112,52)\", \"rgb(245,64,32)\", \"rgb(237,45,28)\", \"rgb(220,24,32)\", \"rgb(180,0,35)\"];\n\n\tvar colorScale = params.colorScale || defaulColorScale;\n\n\tvar NULL_WIND_VECTOR = [NaN, NaN, null]; // singleton for no wind in the form: [u, v, magnitude]\n\n\tvar builder;\n\tvar grid;\n\tvar gridData = params.data;\n\tvar date;\n\tvar λ0, φ0, Δλ, Δφ, ni, nj;\n\n\tvar setData = function setData(data) {\n\t\tgridData = data;\n\t};\n\n\t// interpolation for vectors like wind (u,v,m)\n\tvar bilinearInterpolateVector = function bilinearInterpolateVector(x, y, g00, g10, g01, g11) {\n\t\tvar rx = 1 - x;\n\t\tvar ry = 1 - y;\n\t\tvar a = rx * ry,\n\t\t    b = x * ry,\n\t\t    c = rx * y,\n\t\t    d = x * y;\n\t\tvar u = g00[0] * a + g10[0] * b + g01[0] * c + g11[0] * d;\n\t\tvar v = g00[1] * a + g10[1] * b + g01[1] * c + g11[1] * d;\n\t\treturn [u, v, Math.sqrt(u * u + v * v)];\n\t};\n\n\tvar createWindBuilder = function createWindBuilder(uComp, vComp) {\n\t\tvar uData = uComp.data,\n\t\t    vData = vComp.data;\n\t\treturn {\n\t\t\theader: uComp.header,\n\t\t\t//recipe: recipeFor(\"wind-\" + uComp.header.surface1Value),\n\t\t\tdata: function data(i) {\n\t\t\t\treturn [uData[i], vData[i]];\n\t\t\t},\n\t\t\tinterpolate: bilinearInterpolateVector\n\t\t};\n\t};\n\n\tvar createBuilder = function createBuilder(data) {\n\t\tvar uComp = null,\n\t\t    vComp = null,\n\t\t    scalar = null;\n\n\t\tdata.forEach(function (record) {\n\t\t\tswitch (record.header.parameterCategory + \",\" + record.header.parameterNumber) {\n\t\t\t\tcase \"1,2\":\n\t\t\t\tcase \"2,2\":\n\t\t\t\t\tuComp = record;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1,3\":\n\t\t\t\tcase \"2,3\":\n\t\t\t\t\tvComp = record;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tscalar = record;\n\t\t\t}\n\t\t});\n\n\t\treturn createWindBuilder(uComp, vComp);\n\t};\n\n\tvar buildGrid = function buildGrid(data, callback) {\n\n\t\tbuilder = createBuilder(data);\n\t\tvar header = builder.header;\n\n\t\tλ0 = header.lo1;\n\t\tφ0 = header.la1; // the grid's origin (e.g., 0.0E, 90.0N)\n\n\t\tΔλ = header.dx;\n\t\tΔφ = header.dy; // distance between grid points (e.g., 2.5 deg lon, 2.5 deg lat)\n\n\t\tni = header.nx;\n\t\tnj = header.ny; // number of grid points W-E and N-S (e.g., 144 x 73)\n\n\t\tdate = new Date(header.refTime);\n\t\tdate.setHours(date.getHours() + header.forecastTime);\n\n\t\t// Scan mode 0 assumed. Longitude increases from λ0, and latitude decreases from φ0.\n\t\t// http://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_table3-4.shtml\n\t\tgrid = [];\n\t\tvar p = 0;\n\t\tvar isContinuous = Math.floor(ni * Δλ) >= 360;\n\n\t\tfor (var j = 0; j < nj; j++) {\n\t\t\tvar row = [];\n\t\t\tfor (var i = 0; i < ni; i++, p++) {\n\t\t\t\trow[i] = builder.data(p);\n\t\t\t}\n\t\t\tif (isContinuous) {\n\t\t\t\t// For wrapped grids, duplicate first column as last column to simplify interpolation logic\n\t\t\t\trow.push(row[0]);\n\t\t\t}\n\t\t\tgrid[j] = row;\n\t\t}\n\n\t\tcallback({\n\t\t\tdate: date,\n\t\t\tinterpolate: interpolate\n\t\t});\n\t};\n\n\t/**\n  * Get interpolated grid value from Lon/Lat position\n  * @param λ {Float} Longitude\n  * @param φ {Float} Latitude\n  * @returns {Object}\n  */\n\tvar interpolate = function interpolate(λ, φ) {\n\n\t\tif (!grid) return null;\n\n\t\tvar i = floorMod(λ - λ0, 360) / Δλ; // calculate longitude index in wrapped range [0, 360)\n\t\tvar j = (φ0 - φ) / Δφ; // calculate latitude index in direction +90 to -90\n\n\t\tvar fi = Math.floor(i),\n\t\t    ci = fi + 1;\n\t\tvar fj = Math.floor(j),\n\t\t    cj = fj + 1;\n\n\t\tvar row;\n\t\tif (row = grid[fj]) {\n\t\t\tvar g00 = row[fi];\n\t\t\tvar g10 = row[ci];\n\t\t\tif (isValue(g00) && isValue(g10) && (row = grid[cj])) {\n\t\t\t\tvar g01 = row[fi];\n\t\t\t\tvar g11 = row[ci];\n\t\t\t\tif (isValue(g01) && isValue(g11)) {\n\t\t\t\t\t// All four points found, so interpolate the value.\n\t\t\t\t\treturn builder.interpolate(i - fi, j - fj, g00, g10, g01, g11);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n  * @returns {Boolean} true if the specified value is not null and not undefined.\n  */\n\tvar isValue = function isValue(x) {\n\t\treturn x !== null && x !== undefined;\n\t};\n\n\t/**\n  * @returns {Number} returns remainder of floored division, i.e., floor(a / n). Useful for consistent modulo\n  *          of negative numbers. See http://en.wikipedia.org/wiki/Modulo_operation.\n  */\n\tvar floorMod = function floorMod(a, n) {\n\t\treturn a - n * Math.floor(a / n);\n\t};\n\n\t/**\n  * @returns {Number} the value x clamped to the range [low, high].\n  */\n\tvar clamp = function clamp(x, range) {\n\t\treturn Math.max(range[0], Math.min(x, range[1]));\n\t};\n\n\t/**\n  * @returns {Boolean} true if agent is probably a mobile device. Don't really care if this is accurate.\n  */\n\tvar isMobile = function isMobile() {\n\t\treturn (/android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i.test(navigator.userAgent)\n\t\t);\n\t};\n\n\t/**\n  * Calculate distortion of the wind vector caused by the shape of the projection at point (x, y). The wind\n  * vector is modified in place and returned by this function.\n  */\n\tvar distort = function distort(projection, λ, φ, x, y, scale, wind, windy) {\n\t\tvar u = wind[0] * scale;\n\t\tvar v = wind[1] * scale;\n\t\tvar d = distortion(projection, λ, φ, x, y, windy);\n\n\t\t// Scale distortion vectors by u and v, then add.\n\t\twind[0] = d[0] * u + d[2] * v;\n\t\twind[1] = d[1] * u + d[3] * v;\n\t\treturn wind;\n\t};\n\n\tvar distortion = function distortion(projection, λ, φ, x, y, windy) {\n\t\tvar τ = 2 * Math.PI;\n\t\tvar H = Math.pow(10, -5.2);\n\t\tvar hλ = λ < 0 ? H : -H;\n\t\tvar hφ = φ < 0 ? H : -H;\n\n\t\tvar pλ = project(φ, λ + hλ, windy);\n\t\tvar pφ = project(φ + hφ, λ, windy);\n\n\t\t// Meridian scale factor (see Snyder, equation 4-3), where R = 1. This handles issue where length of 1º λ\n\t\t// changes depending on φ. Without this, there is a pinching effect at the poles.\n\t\tvar k = Math.cos(φ / 360 * τ);\n\t\treturn [(pλ[0] - x) / hλ / k, (pλ[1] - y) / hλ / k, (pφ[0] - x) / hφ, (pφ[1] - y) / hφ];\n\t};\n\n\tvar createField = function createField(columns, bounds, callback) {\n\n\t\t/**\n   * @returns {Array} wind vector [u, v, magnitude] at the point (x, y), or [NaN, NaN, null] if wind\n   *          is undefined at that point.\n   */\n\t\tfunction field(x, y) {\n\t\t\tvar column = columns[Math.round(x)];\n\t\t\treturn column && column[Math.round(y)] || NULL_WIND_VECTOR;\n\t\t}\n\n\t\t// Frees the massive \"columns\" array for GC. Without this, the array is leaked (in Chrome) each time a new\n\t\t// field is interpolated because the field closure's context is leaked, for reasons that defy explanation.\n\t\tfield.release = function () {\n\t\t\tcolumns = [];\n\t\t};\n\n\t\tfield.randomize = function (o) {\n\t\t\t// UNDONE: this method is terrible\n\t\t\tvar x, y;\n\t\t\tvar safetyNet = 0;\n\t\t\tdo {\n\t\t\t\tx = Math.round(Math.floor(Math.random() * bounds.width) + bounds.x);\n\t\t\t\ty = Math.round(Math.floor(Math.random() * bounds.height) + bounds.y);\n\t\t\t} while (field(x, y)[2] === null && safetyNet++ < 30);\n\t\t\to.x = x;\n\t\t\to.y = y;\n\t\t\treturn o;\n\t\t};\n\n\t\tcallback(bounds, field);\n\t};\n\n\tvar buildBounds = function buildBounds(bounds, width, height) {\n\t\tvar upperLeft = bounds[0];\n\t\tvar lowerRight = bounds[1];\n\t\tvar x = Math.round(upperLeft[0]); //Math.max(Math.floor(upperLeft[0], 0), 0);\n\t\tvar y = Math.max(Math.floor(upperLeft[1], 0), 0);\n\t\tvar xMax = Math.min(Math.ceil(lowerRight[0], width), width - 1);\n\t\tvar yMax = Math.min(Math.ceil(lowerRight[1], height), height - 1);\n\t\treturn { x: x, y: y, xMax: width, yMax: yMax, width: width, height: height };\n\t};\n\n\tvar deg2rad = function deg2rad(deg) {\n\t\treturn deg / 180 * Math.PI;\n\t};\n\n\tvar rad2deg = function rad2deg(ang) {\n\t\treturn ang / (Math.PI / 180.0);\n\t};\n\n\tvar invert = function invert(x, y, windy) {\n\t\tvar mapLonDelta = windy.east - windy.west;\n\t\tvar worldMapRadius = windy.width / rad2deg(mapLonDelta) * 360 / (2 * Math.PI);\n\t\tvar mapOffsetY = worldMapRadius / 2 * Math.log((1 + Math.sin(windy.south)) / (1 - Math.sin(windy.south)));\n\t\tvar equatorY = windy.height + mapOffsetY;\n\t\tvar a = (equatorY - y) / worldMapRadius;\n\n\t\tvar lat = 180 / Math.PI * (2 * Math.atan(Math.exp(a)) - Math.PI / 2);\n\t\tvar lon = rad2deg(windy.west) + x / windy.width * rad2deg(mapLonDelta);\n\t\treturn [lon, lat];\n\t};\n\n\tvar mercY = function mercY(lat) {\n\t\treturn Math.log(Math.tan(lat / 2 + Math.PI / 4));\n\t};\n\n\tvar project = function project(lat, lon, windy) {\n\t\t// both in radians, use deg2rad if neccessary\n\t\tvar ymin = mercY(windy.south);\n\t\tvar ymax = mercY(windy.north);\n\t\tvar xFactor = windy.width / (windy.east - windy.west);\n\t\tvar yFactor = windy.height / (ymax - ymin);\n\n\t\tvar y = mercY(deg2rad(lat));\n\t\tvar x = (deg2rad(lon) - windy.west) * xFactor;\n\t\tvar y = (ymax - y) * yFactor; // y points south\n\t\treturn [x, y];\n\t};\n\n\tvar interpolateField = function interpolateField(grid, bounds, extent, callback) {\n\n\t\tvar projection = {};\n\t\tvar mapArea = (extent.south - extent.north) * (extent.west - extent.east);\n\t\tvar velocityScale = VELOCITY_SCALE * Math.pow(mapArea, 0.4);\n\n\t\tvar columns = [];\n\t\tvar x = bounds.x;\n\n\t\tfunction interpolateColumn(x) {\n\t\t\tvar column = [];\n\t\t\tfor (var y = bounds.y; y <= bounds.yMax; y += 2) {\n\t\t\t\tvar coord = invert(x, y, extent);\n\t\t\t\tif (coord) {\n\t\t\t\t\tvar λ = coord[0],\n\t\t\t\t\t    φ = coord[1];\n\t\t\t\t\tif (isFinite(λ)) {\n\t\t\t\t\t\tvar wind = grid.interpolate(λ, φ);\n\t\t\t\t\t\tif (wind) {\n\t\t\t\t\t\t\twind = distort(projection, λ, φ, x, y, velocityScale, wind, extent);\n\t\t\t\t\t\t\tcolumn[y + 1] = column[y] = wind;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolumns[x + 1] = columns[x] = column;\n\t\t}\n\n\t\t(function batchInterpolate() {\n\t\t\tvar start = Date.now();\n\t\t\twhile (x < bounds.width) {\n\t\t\t\tinterpolateColumn(x);\n\t\t\t\tx += 2;\n\t\t\t\tif (Date.now() - start > 1000) {\n\t\t\t\t\t//MAX_TASK_TIME) {\n\t\t\t\t\tsetTimeout(batchInterpolate, 25);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcreateField(columns, bounds, callback);\n\t\t})();\n\t};\n\n\tvar animationLoop;\n\tvar animate = function animate(bounds, field) {\n\n\t\tfunction windIntensityColorScale(min, max) {\n\n\t\t\tcolorScale.indexFor = function (m) {\n\t\t\t\t// map velocity speed to a style\n\t\t\t\treturn Math.max(0, Math.min(colorScale.length - 1, Math.round((m - min) / (max - min) * (colorScale.length - 1))));\n\t\t\t};\n\n\t\t\treturn colorScale;\n\t\t}\n\n\t\tvar colorStyles = windIntensityColorScale(MIN_VELOCITY_INTENSITY, MAX_VELOCITY_INTENSITY);\n\t\tvar buckets = colorStyles.map(function () {\n\t\t\treturn [];\n\t\t});\n\n\t\tvar particleCount = Math.round(bounds.width * bounds.height * PARTICLE_MULTIPLIER);\n\t\tif (isMobile()) {\n\t\t\tparticleCount *= PARTICLE_REDUCTION;\n\t\t}\n\n\t\tvar fadeFillStyle = \"rgba(0, 0, 0, 0.97)\";\n\n\t\tvar particles = [];\n\t\tfor (var i = 0; i < particleCount; i++) {\n\t\t\tparticles.push(field.randomize({ age: Math.floor(Math.random() * MAX_PARTICLE_AGE) + 0 }));\n\t\t}\n\n\t\tfunction evolve() {\n\t\t\tbuckets.forEach(function (bucket) {\n\t\t\t\tbucket.length = 0;\n\t\t\t});\n\t\t\tparticles.forEach(function (particle) {\n\t\t\t\tif (particle.age > MAX_PARTICLE_AGE) {\n\t\t\t\t\tfield.randomize(particle).age = 0;\n\t\t\t\t}\n\t\t\t\tvar x = particle.x;\n\t\t\t\tvar y = particle.y;\n\t\t\t\tvar v = field(x, y); // vector at current position\n\t\t\t\tvar m = v[2];\n\t\t\t\tif (m === null) {\n\t\t\t\t\tparticle.age = MAX_PARTICLE_AGE; // particle has escaped the grid, never to return...\n\t\t\t\t} else {\n\t\t\t\t\tvar xt = x + v[0];\n\t\t\t\t\tvar yt = y + v[1];\n\t\t\t\t\tif (field(xt, yt)[2] !== null) {\n\t\t\t\t\t\t// Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.\n\t\t\t\t\t\tparticle.xt = xt;\n\t\t\t\t\t\tparticle.yt = yt;\n\t\t\t\t\t\tbuckets[colorStyles.indexFor(m)].push(particle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Particle isn't visible, but it still moves through the field.\n\t\t\t\t\t\tparticle.x = xt;\n\t\t\t\t\t\tparticle.y = yt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparticle.age += 1;\n\t\t\t});\n\t\t}\n\n\t\tvar g = params.canvas.getContext(\"2d\");\n\t\tg.lineWidth = PARTICLE_LINE_WIDTH;\n\t\tg.fillStyle = fadeFillStyle;\n\t\tg.globalAlpha = 0.6;\n\n\t\tfunction draw() {\n\t\t\t// Fade existing particle trails.\n\t\t\tvar prev = \"lighter\";\n\t\t\tg.globalCompositeOperation = \"destination-in\";\n\t\t\tg.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\t\t\tg.globalCompositeOperation = prev;\n\t\t\tg.globalAlpha = 0.9;\n\n\t\t\t// Draw new particle trails.\n\t\t\tbuckets.forEach(function (bucket, i) {\n\t\t\t\tif (bucket.length > 0) {\n\t\t\t\t\tg.beginPath();\n\t\t\t\t\tg.strokeStyle = colorStyles[i];\n\t\t\t\t\tbucket.forEach(function (particle) {\n\t\t\t\t\t\tg.moveTo(particle.x, particle.y);\n\t\t\t\t\t\tg.lineTo(particle.xt, particle.yt);\n\t\t\t\t\t\tparticle.x = particle.xt;\n\t\t\t\t\t\tparticle.y = particle.yt;\n\t\t\t\t\t});\n\t\t\t\t\tg.stroke();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar then = Date.now();\n\t\t(function frame() {\n\t\t\tanimationLoop = requestAnimationFrame(frame);\n\t\t\tvar now = Date.now();\n\t\t\tvar delta = now - then;\n\t\t\tif (delta > FRAME_TIME) {\n\t\t\t\tthen = now - delta % FRAME_TIME;\n\t\t\t\tevolve();\n\t\t\t\tdraw();\n\t\t\t}\n\t\t})();\n\t};\n\n\tvar start = function start(bounds, width, height, extent) {\n\n\t\tvar mapBounds = {\n\t\t\tsouth: deg2rad(extent[0][1]),\n\t\t\tnorth: deg2rad(extent[1][1]),\n\t\t\teast: deg2rad(extent[1][0]),\n\t\t\twest: deg2rad(extent[0][0]),\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tstop();\n\n\t\t// build grid\n\t\tbuildGrid(gridData, function (grid) {\n\t\t\t// interpolateField\n\t\t\tinterpolateField(grid, buildBounds(bounds, width, height), mapBounds, function (bounds, field) {\n\t\t\t\t// animate the canvas with random points\n\t\t\t\twindy.field = field;\n\t\t\t\tanimate(bounds, field);\n\t\t\t});\n\t\t});\n\t};\n\n\tvar stop = function stop() {\n\t\tif (windy.field) windy.field.release();\n\t\tL.Util.cancelAnimFrame(animationLoop);\n\t};\n\n\tvar windy = {\n\t\tparams: params,\n\t\tstart: start,\n\t\tstop: stop,\n\t\tcreateField: createField,\n\t\tinterpolatePoint: interpolate,\n\t\tsetData: setData\n\t};\n\n\treturn windy;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Windy);\n\n/***/ }),\n\n/***/ 159:\n/***/ (function(module, exports) {\n\n/**\n * \n */\nL.Control.Velocity = L.Control.extend({\n\n    options: {\n        position: 'bottomright',\n        emptyString: 'Unavailable',\n        // Could be any combination of 'bearing' (angle toward which the flow goes) or 'meteo' (angle from which the flow comes)\n        // and 'CW' (angle value increases clock-wise) or 'CCW' (angle value increases counter clock-wise)\n        angleConvention: 'bearingCCW',\n        // Could be 'm/s' for meter per second, 'k/h' for kilometer per hour or 'kt' for knots\n        speedUnit: 'm/s'\n    },\n\n    onAdd: function onAdd(map) {\n        this._container = T.div('leaflet-control-velocity');\n        L.DomEvent.disableClickPropagation(this._container);\n        map.on('mousemove', this._onMouseMove, this);\n        this._container.innerHTML = this.options.emptyString;\n        return this._container;\n    },\n\n    onRemove: function onRemove(map) {\n        map.off('mousemove', this._onMouseMove, this);\n    },\n\n    vectorToSpeed: function vectorToSpeed(uMs, vMs, unit) {\n        var velocityAbs = Math.sqrt(Math.pow(uMs, 2) + Math.pow(vMs, 2));\n        // Default is m/s\n        if (unit === 'k/h') {\n            return this.meterSec2kilometerHour(velocityAbs);\n        } else if (unit === 'kt') {\n            return this.meterSec2Knots(velocityAbs);\n        } else {\n            return velocityAbs;\n        }\n    },\n\n    vectorToDegrees: function vectorToDegrees(uMs, vMs, angleConvention) {\n\n        // Default angle convention is CW\n        if (angleConvention.endsWith('CCW')) {\n            // vMs comes out upside-down..\n            vMs = vMs > 0 ? vMs = -vMs : Math.abs(vMs);\n        }\n        var velocityAbs = Math.sqrt(Math.pow(uMs, 2) + Math.pow(vMs, 2));\n\n        var velocityDir = Math.atan2(uMs / velocityAbs, vMs / velocityAbs);\n        var velocityDirToDegrees = velocityDir * 180 / Math.PI + 180;\n\n        if (angleConvention === 'bearingCW' || angleConvention === 'meteoCCW') {\n            velocityDirToDegrees += 180;\n            if (velocityDirToDegrees >= 360) velocityDirToDegrees -= 360;\n        }\n\n        return velocityDirToDegrees;\n    },\n\n    meterSec2Knots: function meterSec2Knots(meters) {\n        return meters / 0.514;\n    },\n\n    meterSec2kilometerHour: function meterSec2kilometerHour(meters) {\n        return meters * 3.6;\n    },\n\n    _onMouseMove: function _onMouseMove(e) {\n\n        var self = this;\n        var pos = this.options.leafletVelocity._map.containerPointToLatLng(L.point(e.containerPoint.x, e.containerPoint.y));\n        var gridValue = this.options.leafletVelocity._windy.interpolatePoint(pos.lng, pos.lat);\n        var htmlOut = \"\";\n\n        if (gridValue && !isNaN(gridValue[0]) && !isNaN(gridValue[1]) && gridValue[2]) {\n            htmlOut = \"<strong>\" + this.options.velocityType + \" Direction: </strong>\" + self.vectorToDegrees(gridValue[0], gridValue[1], this.options.angleConvention).toFixed(3) + \"°\" + \", <strong>\" + this.options.velocityType + \" Speed: </strong>\" + self.vectorToSpeed(gridValue[0], gridValue[1]).toFixed(1) + \"m/s\";\n        } else {\n            htmlOut = this.options.emptyString;\n        }\n\n        self._container.innerHTML = htmlOut;\n\n        // move control to bottom row\n        // if(T('.leaflet-control-velocity').index() == 0){\n        //     T('.leaflet-control-velocity').insertAfter('.leaflet-control-mouseposition');\n        // }\n    }\n});\n\nL.Map.mergeOptions({\n    positionControl: false\n});\n\nL.Map.addInitHook(function () {\n    if (this.options.positionControl) {\n        this.positionControl = new L.Control.MousePosition();\n        this.addControl(this.positionControl);\n    }\n});\n\nL.control.velocity = function (options) {\n    return new L.Control.Velocity(options);\n};\n\n/***/ })\n\n/******/ })});;\n\n\n// WEBPACK FOOTER //\n// plugins/velocityLayer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dist/dmap/leaflet/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 156);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7b19f38a437100774b0e","/**\r\n * @author gyb(mocheer)\r\n * @email `mocheer@foxmail.com`  \r\n * @since 2018.8.31\r\n */\r\nimport '@/plugins/velocity/L.VelocityLayer';\r\n/**\r\n * \r\n */\r\nexport default (data,options) => L.velocityLayer(T.assign({\r\n  displayValues: true,\r\n  displayOptions: {\r\n    velocityType: 'GBR Wind',\r\n    displayPosition: 'bottomleft',\r\n    displayEmptyString: 'No wind data'\r\n    // velocityType: 'Global Wind',\r\n    // position: 'bottomleft',\r\n    // emptyString: 'No velocity data',\r\n    // angleConvention: 'bearingCW',\r\n    // displayPosition: 'bottomleft',\r\n    // displayEmptyString: 'No velocity data',\r\n    // speedUnit: 'kt'\r\n  },\r\n  data: data,                //grib2.json\r\n  // OPTIONAL\r\n  // minVelocity: 0,          // used to align color scale\r\n  // maxVelocity: 10,         // used to align color scale\r\n  // velocityScale: 0.005,    // modifier for particle animations, arbitrarily defaults to 0.005\r\n  // colorScale: []           // define your own array of hex/rgb colors\r\n  maxVelocity: 10\r\n}, options));\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/VelocityLayer.js","/**\n * @see https://github.com/danwild/leaflet-velocity\n */\nimport Windy from './Windy'\nimport './L.Control.Velocity'\n/**\n * \n */\nL.VelocityLayer = L.Layer.extend({//L.Class.extend\n\toptions: {\n\t\tdisplayValues: true,\n\t\tdisplayOptions: {\n\t\t\tvelocityType: 'Velocity',\n\t\t\tposition: 'bottomleft',\n\t\t\temptyString: 'No velocity data'\n\t\t},\n\t\tmaxVelocity: 10, // used to align color scale\n\t\tcolorScale: null,\n\t\tdata: null\n\t},\n\t// _map: null,\n\t// _canvasLayer: null,\n\t// _windy: null,\n\t// _context: null,\n\t// _mouseControl: null, //底部风力信息\n\t_timer: 0,\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t\tthis.ajax = T.one(url => T.ajax({ f: 'json', url: url, success: data => { this.setData(data) } }))\n\t},\n\n\tonAdd: function (map) {\n\t\t// create canvas, add overlay control\n\t\tthis._canvasLayer = L.canvasLayer().delegate(this);\n\t\tthis._canvasLayer.addTo(map);\n\t\tthis._map = map;\n\t},\n\n\tonRemove: function (map) {\n\t\tthis._destroyWind();\n\t},\n\n\tsetData: function setData(data) {\n\t\tthis.options.data = data;\n\n\t\tif (this._windy) {\n\t\t\tthis._windy.setData(data);\n\t\t\tthis._clearAndRestart();\n\t\t}\n\n\t\tthis.fire('load');\n\t},\n\n\tonDrawLayer: function (overlay, params) {\n\t\tlet self = this,\n\t\t\t{ _windy, options, _timer } = self;\n\t\tif (!this._windy) {\n\t\t\tthis._initWindy(self);\n\t\t\treturn;\n\t\t}\n\t\tlet { data, url } = options;\n\t\tif (!data) {\n\t\t\turl && this.ajax(url)\n\t\t\treturn;\n\t\t}\n\n\t\tif (_timer) clearTimeout(_timer);\n\n\t\tthis._timer = setTimeout(function () {\n\t\t\tself._startWindy();\n\t\t}, 750);\n\t},\n\n\t_startWindy: function () {\n\t\tvar bounds = this._map.getBounds();\n\t\tvar size = this._map.getSize();\n\n\t\t// bounds, width, height, extent\n\t\tthis._windy.start(\n\t\t\t[\n\t\t\t\t[0, 0],\n\t\t\t\t[size.x, size.y]\n\t\t\t],\n\t\t\tsize.x,\n\t\t\tsize.y,\n\t\t\t[\n\t\t\t\t[bounds._southWest.lng, bounds._southWest.lat],\n\t\t\t\t[bounds._northEast.lng, bounds._northEast.lat]\n\t\t\t]);\n\t},\n\n\t_initWindy: function (self) {\n\t\tthis._windy = new Windy(T.assign({ canvas: self._canvasLayer._canvas }, self.options));\n\n\t\t// prepare context global var, start drawing\n\t\tthis._context = this._canvasLayer._canvas.getContext('2d');\n\t\tthis._canvasLayer._canvas.classList.add(\"velocity-overlay\");\n\t\tthis.onDrawLayer();\n\n\t\tthis._map.on('dragstart', self._windy.stop)\n\t\t\t.on('dragend', self._clearAndRestart)\n\t\t\t.on('zoomstart', self._windy.stop)\n\t\t\t.on('zoomend', self._clearAndRestart)\n\t\t\t.on('resize', self._clearWind);\n\n\t\tthis._initMouseHandler();\n\t},\n\n\t_initMouseHandler: function () {\n\t\tif (!this._mouseControl && this.options.displayValues) {\n\t\t\tvar options = this.options.displayOptions || {};\n\t\t\toptions['leafletVelocity'] = this;\n\t\t\tthis._mouseControl = L.control.velocity(options).addTo(this._map);\n\t\t}\n\t},\n\n\t_clearAndRestart: function () {\n\t\tif (this._context) this._context.clearRect(0, 0, 3000, 3000);\n\t\tif (this._windy) this._startWindy();\n\t},\n\n\t_clearWind: function () {\n\t\tif (this._windy) this._windy.stop();\n\t\tif (this._context) this._context.clearRect(0, 0, 3000, 3000);\n\t},\n\n\t_destroyWind: function () {\n\t\tif (this._timer) clearTimeout(this._timer);\n\t\tif (this._windy) this._windy.stop();\n\t\tif (this._context) this._context.clearRect(0, 0, 3000, 3000);\n\t\tif (this._mouseControl) this._map.removeControl(this._mouseControl);\n\t\tthis._mouseControl = null;\n\t\tthis._windy = null;\n\t\tthis._map.removeLayer(this._canvasLayer);\n\t}\n});\n\nL.velocityLayer = function (options) {\n\treturn new L.VelocityLayer(options);\n};\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/velocity/L.VelocityLayer.js","/*  Global class for simulating the movement of particle through a 1km wind grid\n\n credit: All the credit for this work goes to: https://github.com/cambecc for creating the repo:\n https://github.com/cambecc/earth. The majority of this code is directly take nfrom there, since its awesome.\n\n This class takes a canvas element and an array of data (1km GFS from http://www.emc.ncep.noaa.gov/index.php?branch=GFS)\n and then uses a mercator (forward/reverse) projection to correctly map wind vectors in \"map space\".\n\n The \"start\" method takes the bounds of the map at its current extent and starts the whole gridding,\n interpolation and animation process.\n */\n\nvar Windy = function (params) {\n\n\tconst MIN_VELOCITY_INTENSITY = params.minVelocity || 0;                      // 粒子最小强度的速度\n\tconst MAX_VELOCITY_INTENSITY = params.maxVelocity || 10;                     // 粒子最大强度的速度\n\tconst VELOCITY_SCALE = (params.velocityScale || 0.005) * (Math.pow(window.devicePixelRatio, 1 / 3) || 1); // 风速因子\n\tconst MAX_PARTICLE_AGE = params.particleAge || 90;                         \t // 粒子运动次数\n\tconst PARTICLE_LINE_WIDTH = params.lineWidth || 1;                           // 粒子宽度\n\tconst PARTICLE_MULTIPLIER = params.particleMultiplier || 1 / 300;            // particle count scalar (completely arbitrary--this values looks nice)\n\tconst PARTICLE_REDUCTION = (Math.pow(window.devicePixelRatio, 1 / 3) || 1.6);   // multiply particle count for mobiles by this amount\n\tconst FRAME_RATE = params.frameRate || 15, FRAME_TIME = 1000 / FRAME_RATE;   // desired frames per second\n\n\tvar defaulColorScale = [\n\t\t\"rgb(36,104, 180)\",\n\t\t\"rgb(60,157, 194)\",\n\t\t\"rgb(128,205,193 )\",\n\t\t\"rgb(151,218,168 )\",\n\t\t\"rgb(198,231,181)\",\n\t\t\"rgb(238,247,217)\",\n\t\t\"rgb(255,238,159)\",\n\t\t\"rgb(252,217,125)\",\n\t\t\"rgb(255,182,100)\",\n\t\t\"rgb(252,150,75)\",\n\t\t\"rgb(250,112,52)\",\n\t\t\"rgb(245,64,32)\",\n\t\t\"rgb(237,45,28)\",\n\t\t\"rgb(220,24,32)\",\n\t\t\"rgb(180,0,35)\"\n\t];\n\n\tconst colorScale = params.colorScale || defaulColorScale;\n\n\tvar NULL_WIND_VECTOR = [NaN, NaN, null];  // singleton for no wind in the form: [u, v, magnitude]\n\n\tvar builder;\n\tvar grid;\n\tvar gridData = params.data;\n\tvar date;\n\tvar λ0, φ0, Δλ, Δφ, ni, nj;\n\n\tvar setData = function (data) {\n\t\tgridData = data;\n\t};\n\n\t// interpolation for vectors like wind (u,v,m)\n\tvar bilinearInterpolateVector = function (x, y, g00, g10, g01, g11) {\n\t\tvar rx = (1 - x);\n\t\tvar ry = (1 - y);\n\t\tvar a = rx * ry, b = x * ry, c = rx * y, d = x * y;\n\t\tvar u = g00[0] * a + g10[0] * b + g01[0] * c + g11[0] * d;\n\t\tvar v = g00[1] * a + g10[1] * b + g01[1] * c + g11[1] * d;\n\t\treturn [u, v, Math.sqrt(u * u + v * v)];\n\t};\n\n\n\tvar createWindBuilder = function (uComp, vComp) {\n\t\tvar uData = uComp.data, vData = vComp.data;\n\t\treturn {\n\t\t\theader: uComp.header,\n\t\t\t//recipe: recipeFor(\"wind-\" + uComp.header.surface1Value),\n\t\t\tdata: function (i) {\n\t\t\t\treturn [uData[i], vData[i]];\n\t\t\t},\n\t\t\tinterpolate: bilinearInterpolateVector\n\t\t}\n\t};\n\n\tvar createBuilder = function (data) {\n\t\tvar uComp = null, vComp = null, scalar = null;\n\n\t\tdata.forEach(function (record) {\n\t\t\tswitch (record.header.parameterCategory + \",\" + record.header.parameterNumber) {\n\t\t\t\tcase \"1,2\":\n\t\t\t\tcase \"2,2\":\n\t\t\t\t\tuComp = record;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"1,3\":\n\t\t\t\tcase \"2,3\":\n\t\t\t\t\tvComp = record;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tscalar = record;\n\t\t\t}\n\t\t});\n\n\t\treturn createWindBuilder(uComp, vComp);\n\t};\n\n\tvar buildGrid = function (data, callback) {\n\n\t\tbuilder = createBuilder(data);\n\t\tvar header = builder.header;\n\n\t\tλ0 = header.lo1;\n\t\tφ0 = header.la1;  // the grid's origin (e.g., 0.0E, 90.0N)\n\n\t\tΔλ = header.dx;\n\t\tΔφ = header.dy;    // distance between grid points (e.g., 2.5 deg lon, 2.5 deg lat)\n\n\t\tni = header.nx;\n\t\tnj = header.ny;    // number of grid points W-E and N-S (e.g., 144 x 73)\n\n\t\tdate = new Date(header.refTime);\n\t\tdate.setHours(date.getHours() + header.forecastTime);\n\n\t\t// Scan mode 0 assumed. Longitude increases from λ0, and latitude decreases from φ0.\n\t\t// http://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_table3-4.shtml\n\t\tgrid = [];\n\t\tvar p = 0;\n\t\tvar isContinuous = Math.floor(ni * Δλ) >= 360;\n\n\t\tfor (var j = 0; j < nj; j++) {\n\t\t\tvar row = [];\n\t\t\tfor (var i = 0; i < ni; i++ , p++) {\n\t\t\t\trow[i] = builder.data(p);\n\t\t\t}\n\t\t\tif (isContinuous) {\n\t\t\t\t// For wrapped grids, duplicate first column as last column to simplify interpolation logic\n\t\t\t\trow.push(row[0]);\n\t\t\t}\n\t\t\tgrid[j] = row;\n\t\t}\n\n\t\tcallback({\n\t\t\tdate: date,\n\t\t\tinterpolate: interpolate\n\t\t});\n\t};\n\n\t/**\n\t * Get interpolated grid value from Lon/Lat position\n\t * @param λ {Float} Longitude\n\t * @param φ {Float} Latitude\n\t * @returns {Object}\n\t */\n\tvar interpolate = function (λ, φ) {\n\n\t\tif (!grid) return null;\n\n\t\tvar i = floorMod(λ - λ0, 360) / Δλ;  // calculate longitude index in wrapped range [0, 360)\n\t\tvar j = (φ0 - φ) / Δφ;                 // calculate latitude index in direction +90 to -90\n\n\t\tvar fi = Math.floor(i), ci = fi + 1;\n\t\tvar fj = Math.floor(j), cj = fj + 1;\n\n\t\tvar row;\n\t\tif ((row = grid[fj])) {\n\t\t\tvar g00 = row[fi];\n\t\t\tvar g10 = row[ci];\n\t\t\tif (isValue(g00) && isValue(g10) && (row = grid[cj])) {\n\t\t\t\tvar g01 = row[fi];\n\t\t\t\tvar g11 = row[ci];\n\t\t\t\tif (isValue(g01) && isValue(g11)) {\n\t\t\t\t\t// All four points found, so interpolate the value.\n\t\t\t\t\treturn builder.interpolate(i - fi, j - fj, g00, g10, g01, g11);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\n\t/**\n\t * @returns {Boolean} true if the specified value is not null and not undefined.\n\t */\n\tvar isValue = function (x) {\n\t\treturn x !== null && x !== undefined;\n\t};\n\n\t/**\n\t * @returns {Number} returns remainder of floored division, i.e., floor(a / n). Useful for consistent modulo\n\t *          of negative numbers. See http://en.wikipedia.org/wiki/Modulo_operation.\n\t */\n\tvar floorMod = function (a, n) {\n\t\treturn a - n * Math.floor(a / n);\n\t};\n\n\t/**\n\t * @returns {Number} the value x clamped to the range [low, high].\n\t */\n\tvar clamp = function (x, range) {\n\t\treturn Math.max(range[0], Math.min(x, range[1]));\n\t};\n\n\t/**\n\t * @returns {Boolean} true if agent is probably a mobile device. Don't really care if this is accurate.\n\t */\n\tvar isMobile = function () {\n\t\treturn (/android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i).test(navigator.userAgent);\n\t};\n\n\t/**\n\t * Calculate distortion of the wind vector caused by the shape of the projection at point (x, y). The wind\n\t * vector is modified in place and returned by this function.\n\t */\n\tvar distort = function (projection, λ, φ, x, y, scale, wind, windy) {\n\t\tvar u = wind[0] * scale;\n\t\tvar v = wind[1] * scale;\n\t\tvar d = distortion(projection, λ, φ, x, y, windy);\n\n\t\t// Scale distortion vectors by u and v, then add.\n\t\twind[0] = d[0] * u + d[2] * v;\n\t\twind[1] = d[1] * u + d[3] * v;\n\t\treturn wind;\n\t};\n\n\tvar distortion = function (projection, λ, φ, x, y, windy) {\n\t\tvar τ = 2 * Math.PI;\n\t\tvar H = Math.pow(10, -5.2);\n\t\tvar hλ = λ < 0 ? H : -H;\n\t\tvar hφ = φ < 0 ? H : -H;\n\n\t\tvar pλ = project(φ, λ + hλ, windy);\n\t\tvar pφ = project(φ + hφ, λ, windy);\n\n\t\t// Meridian scale factor (see Snyder, equation 4-3), where R = 1. This handles issue where length of 1º λ\n\t\t// changes depending on φ. Without this, there is a pinching effect at the poles.\n\t\tvar k = Math.cos(φ / 360 * τ);\n\t\treturn [\n\t\t\t(pλ[0] - x) / hλ / k,\n\t\t\t(pλ[1] - y) / hλ / k,\n\t\t\t(pφ[0] - x) / hφ,\n\t\t\t(pφ[1] - y) / hφ\n\t\t];\n\t};\n\n\tvar createField = function (columns, bounds, callback) {\n\n\t\t/**\n\t\t * @returns {Array} wind vector [u, v, magnitude] at the point (x, y), or [NaN, NaN, null] if wind\n\t\t *          is undefined at that point.\n\t\t */\n\t\tfunction field(x, y) {\n\t\t\tvar column = columns[Math.round(x)];\n\t\t\treturn column && column[Math.round(y)] || NULL_WIND_VECTOR;\n\t\t}\n\n\t\t// Frees the massive \"columns\" array for GC. Without this, the array is leaked (in Chrome) each time a new\n\t\t// field is interpolated because the field closure's context is leaked, for reasons that defy explanation.\n\t\tfield.release = function () {\n\t\t\tcolumns = [];\n\t\t};\n\n\t\tfield.randomize = function (o) {  // UNDONE: this method is terrible\n\t\t\tvar x, y;\n\t\t\tvar safetyNet = 0;\n\t\t\tdo {\n\t\t\t\tx = Math.round(Math.floor(Math.random() * bounds.width) + bounds.x);\n\t\t\t\ty = Math.round(Math.floor(Math.random() * bounds.height) + bounds.y)\n\t\t\t} while (field(x, y)[2] === null && safetyNet++ < 30);\n\t\t\to.x = x;\n\t\t\to.y = y;\n\t\t\treturn o;\n\t\t};\n\n\t\tcallback(bounds, field);\n\t};\n\n\tvar buildBounds = function (bounds, width, height) {\n\t\tvar upperLeft = bounds[0];\n\t\tvar lowerRight = bounds[1];\n\t\tvar x = Math.round(upperLeft[0]); //Math.max(Math.floor(upperLeft[0], 0), 0);\n\t\tvar y = Math.max(Math.floor(upperLeft[1], 0), 0);\n\t\tvar xMax = Math.min(Math.ceil(lowerRight[0], width), width - 1);\n\t\tvar yMax = Math.min(Math.ceil(lowerRight[1], height), height - 1);\n\t\treturn { x: x, y: y, xMax: width, yMax: yMax, width: width, height: height };\n\t};\n\n\tvar deg2rad = function (deg) {\n\t\treturn (deg / 180) * Math.PI;\n\t};\n\n\tvar rad2deg = function (ang) {\n\t\treturn ang / (Math.PI / 180.0);\n\t};\n\n\tvar invert = function (x, y, windy) {\n\t\tvar mapLonDelta = windy.east - windy.west;\n\t\tvar worldMapRadius = windy.width / rad2deg(mapLonDelta) * 360 / (2 * Math.PI);\n\t\tvar mapOffsetY = (worldMapRadius / 2 * Math.log((1 + Math.sin(windy.south)) / (1 - Math.sin(windy.south))));\n\t\tvar equatorY = windy.height + mapOffsetY;\n\t\tvar a = (equatorY - y) / worldMapRadius;\n\n\t\tvar lat = 180 / Math.PI * (2 * Math.atan(Math.exp(a)) - Math.PI / 2);\n\t\tvar lon = rad2deg(windy.west) + x / windy.width * rad2deg(mapLonDelta);\n\t\treturn [lon, lat];\n\t};\n\n\tvar mercY = function (lat) {\n\t\treturn Math.log(Math.tan(lat / 2 + Math.PI / 4));\n\t};\n\n\n\tvar project = function (lat, lon, windy) { // both in radians, use deg2rad if neccessary\n\t\tvar ymin = mercY(windy.south);\n\t\tvar ymax = mercY(windy.north);\n\t\tvar xFactor = windy.width / (windy.east - windy.west);\n\t\tvar yFactor = windy.height / (ymax - ymin);\n\n\t\tvar y = mercY(deg2rad(lat));\n\t\tvar x = (deg2rad(lon) - windy.west) * xFactor;\n\t\tvar y = (ymax - y) * yFactor; // y points south\n\t\treturn [x, y];\n\t};\n\n\tvar interpolateField = function (grid, bounds, extent, callback) {\n\n\t\tvar projection = {};\n\t\tvar mapArea = ((extent.south - extent.north) * (extent.west - extent.east));\n\t\tvar velocityScale = VELOCITY_SCALE * Math.pow(mapArea, 0.4);\n\n\t\tvar columns = [];\n\t\tvar x = bounds.x;\n\n\t\tfunction interpolateColumn(x) {\n\t\t\tvar column = [];\n\t\t\tfor (var y = bounds.y; y <= bounds.yMax; y += 2) {\n\t\t\t\tvar coord = invert(x, y, extent);\n\t\t\t\tif (coord) {\n\t\t\t\t\tvar λ = coord[0], φ = coord[1];\n\t\t\t\t\tif (isFinite(λ)) {\n\t\t\t\t\t\tvar wind = grid.interpolate(λ, φ);\n\t\t\t\t\t\tif (wind) {\n\t\t\t\t\t\t\twind = distort(projection, λ, φ, x, y, velocityScale, wind, extent);\n\t\t\t\t\t\t\tcolumn[y + 1] = column[y] = wind;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolumns[x + 1] = columns[x] = column;\n\t\t}\n\n\t\t(function batchInterpolate() {\n\t\t\tvar start = Date.now();\n\t\t\twhile (x < bounds.width) {\n\t\t\t\tinterpolateColumn(x);\n\t\t\t\tx += 2;\n\t\t\t\tif ((Date.now() - start) > 1000) { //MAX_TASK_TIME) {\n\t\t\t\t\tsetTimeout(batchInterpolate, 25);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcreateField(columns, bounds, callback);\n\t\t})();\n\t};\n\n\tvar animationLoop;\n\tvar animate = function (bounds, field) {\n\n\t\tfunction windIntensityColorScale(min, max) {\n\n\t\t\tcolorScale.indexFor = function (m) {  // map velocity speed to a style\n\t\t\t\treturn Math.max(0, Math.min((colorScale.length - 1),\n\t\t\t\t\tMath.round((m - min) / (max - min) * (colorScale.length - 1))));\n\n\t\t\t};\n\n\t\t\treturn colorScale;\n\t\t}\n\n\t\tvar colorStyles = windIntensityColorScale(MIN_VELOCITY_INTENSITY, MAX_VELOCITY_INTENSITY);\n\t\tvar buckets = colorStyles.map(function () { return []; });\n\n\t\tvar particleCount = Math.round(bounds.width * bounds.height * PARTICLE_MULTIPLIER);\n\t\tif (isMobile()) {\n\t\t\tparticleCount *= PARTICLE_REDUCTION;\n\t\t}\n\n\t\tvar fadeFillStyle = \"rgba(0, 0, 0, 0.97)\";\n\n\t\tvar particles = [];\n\t\tfor (var i = 0; i < particleCount; i++) {\n\t\t\tparticles.push(field.randomize({ age: Math.floor(Math.random() * MAX_PARTICLE_AGE) + 0 }));\n\t\t}\n\n\t\tfunction evolve() {\n\t\t\tbuckets.forEach(function (bucket) { bucket.length = 0; });\n\t\t\tparticles.forEach(function (particle) {\n\t\t\t\tif (particle.age > MAX_PARTICLE_AGE) {\n\t\t\t\t\tfield.randomize(particle).age = 0;\n\t\t\t\t}\n\t\t\t\tvar x = particle.x;\n\t\t\t\tvar y = particle.y;\n\t\t\t\tvar v = field(x, y);  // vector at current position\n\t\t\t\tvar m = v[2];\n\t\t\t\tif (m === null) {\n\t\t\t\t\tparticle.age = MAX_PARTICLE_AGE;  // particle has escaped the grid, never to return...\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar xt = x + v[0];\n\t\t\t\t\tvar yt = y + v[1];\n\t\t\t\t\tif (field(xt, yt)[2] !== null) {\n\t\t\t\t\t\t// Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.\n\t\t\t\t\t\tparticle.xt = xt;\n\t\t\t\t\t\tparticle.yt = yt;\n\t\t\t\t\t\tbuckets[colorStyles.indexFor(m)].push(particle);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Particle isn't visible, but it still moves through the field.\n\t\t\t\t\t\tparticle.x = xt;\n\t\t\t\t\t\tparticle.y = yt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparticle.age += 1;\n\t\t\t});\n\t\t}\n\n\t\tvar g = params.canvas.getContext(\"2d\");\n\t\tg.lineWidth = PARTICLE_LINE_WIDTH;\n\t\tg.fillStyle = fadeFillStyle;\n\t\tg.globalAlpha = 0.6;\n\n\t\tfunction draw() {\n\t\t\t// Fade existing particle trails.\n\t\t\tvar prev = \"lighter\";\n\t\t\tg.globalCompositeOperation = \"destination-in\";\n\t\t\tg.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\t\t\tg.globalCompositeOperation = prev;\n\t\t\tg.globalAlpha = 0.9;\n\n\t\t\t// Draw new particle trails.\n\t\t\tbuckets.forEach(function (bucket, i) {\n\t\t\t\tif (bucket.length > 0) {\n\t\t\t\t\tg.beginPath();\n\t\t\t\t\tg.strokeStyle = colorStyles[i];\n\t\t\t\t\tbucket.forEach(function (particle) {\n\t\t\t\t\t\tg.moveTo(particle.x, particle.y);\n\t\t\t\t\t\tg.lineTo(particle.xt, particle.yt);\n\t\t\t\t\t\tparticle.x = particle.xt;\n\t\t\t\t\t\tparticle.y = particle.yt;\n\t\t\t\t\t});\n\t\t\t\t\tg.stroke();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar then = Date.now();\n\t\t(function frame() {\n\t\t\tanimationLoop = requestAnimationFrame(frame);\n\t\t\tvar now = Date.now();\n\t\t\tvar delta = now - then;\n\t\t\tif (delta > FRAME_TIME) {\n\t\t\t\tthen = now - (delta % FRAME_TIME);\n\t\t\t\tevolve();\n\t\t\t\tdraw();\n\t\t\t}\n\t\t})();\n\t};\n\n\tvar start = function (bounds, width, height, extent) {\n\n\t\tvar mapBounds = {\n\t\t\tsouth: deg2rad(extent[0][1]),\n\t\t\tnorth: deg2rad(extent[1][1]),\n\t\t\teast: deg2rad(extent[1][0]),\n\t\t\twest: deg2rad(extent[0][0]),\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tstop();\n\n\t\t// build grid\n\t\tbuildGrid(gridData, function (grid) {\n\t\t\t// interpolateField\n\t\t\tinterpolateField(grid, buildBounds(bounds, width, height), mapBounds, function (bounds, field) {\n\t\t\t\t// animate the canvas with random points\n\t\t\t\twindy.field = field;\n\t\t\t\tanimate(bounds, field);\n\t\t\t});\n\n\t\t});\n\t};\n\n\tvar stop = function () {\n\t\tif (windy.field) windy.field.release();\n\t\tL.Util.cancelAnimFrame(animationLoop);\n\t};\n\n\tvar windy = {\n\t\tparams: params,\n\t\tstart: start,\n\t\tstop: stop,\n\t\tcreateField: createField,\n\t\tinterpolatePoint: interpolate,\n\t\tsetData: setData\n\t};\n\n\treturn windy;\n};\n\nexport default Windy;\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/velocity/Windy.js","/**\n * \n */\nL.Control.Velocity = L.Control.extend({\n\n    options: {\n        position: 'bottomright',\n        emptyString: 'Unavailable',\n        // Could be any combination of 'bearing' (angle toward which the flow goes) or 'meteo' (angle from which the flow comes)\n        // and 'CW' (angle value increases clock-wise) or 'CCW' (angle value increases counter clock-wise)\n        angleConvention: 'bearingCCW',\n        // Could be 'm/s' for meter per second, 'k/h' for kilometer per hour or 'kt' for knots\n        speedUnit: 'm/s'\n    },\n\n    onAdd: function (map) {\n        this._container = T.div('leaflet-control-velocity');\n        L.DomEvent.disableClickPropagation(this._container);\n        map.on('mousemove', this._onMouseMove, this);\n        this._container.innerHTML = this.options.emptyString;\n        return this._container;\n    },\n\n    onRemove: function (map) {\n        map.off('mousemove', this._onMouseMove, this)\n    },\n\n    vectorToSpeed: function (uMs, vMs, unit) {\n        var velocityAbs = Math.sqrt(Math.pow(uMs, 2) + Math.pow(vMs, 2));\n        // Default is m/s\n        if (unit === 'k/h') {\n            return this.meterSec2kilometerHour(velocityAbs);\n        } else if (unit === 'kt') {\n            return this.meterSec2Knots(velocityAbs);\n        } else {\n            return velocityAbs;\n        }\n    },\n\n    vectorToDegrees: function (uMs, vMs, angleConvention) {\n\n        // Default angle convention is CW\n        if (angleConvention.endsWith('CCW')) {\n            // vMs comes out upside-down..\n            vMs = vMs > 0 ? vMs = -vMs : Math.abs(vMs);\n        }\n        var velocityAbs = Math.sqrt(Math.pow(uMs, 2) + Math.pow(vMs, 2));\n\n        var velocityDir = Math.atan2(uMs / velocityAbs, vMs / velocityAbs);\n        var velocityDirToDegrees = velocityDir * 180 / Math.PI + 180;\n\n        if (angleConvention === 'bearingCW' || angleConvention === 'meteoCCW') {\n            velocityDirToDegrees += 180;\n            if (velocityDirToDegrees >= 360) velocityDirToDegrees -= 360;\n        }\n\n        return velocityDirToDegrees;\n    },\n\n    meterSec2Knots: function (meters) {\n        return meters / 0.514\n    },\n\n    meterSec2kilometerHour: function (meters) {\n        return meters * 3.6\n    },\n\n    _onMouseMove: function (e) {\n\n        var self = this;\n        var pos = this.options.leafletVelocity._map.containerPointToLatLng(L.point(e.containerPoint.x, e.containerPoint.y));\n        var gridValue = this.options.leafletVelocity._windy.interpolatePoint(pos.lng, pos.lat);\n        var htmlOut = \"\";\n\n        if (gridValue && !isNaN(gridValue[0]) && !isNaN(gridValue[1]) && gridValue[2]) {\n            htmlOut = \"<strong>\" + this.options.velocityType + \" Direction: </strong>\" +\n                self.vectorToDegrees(gridValue[0], gridValue[1], this.options.angleConvention).toFixed(3) +\n                \"°\" + \", <strong>\" + this.options.velocityType + \" Speed: </strong>\" +\n                self.vectorToSpeed(gridValue[0], gridValue[1]).toFixed(1) + \"m/s\";\n        }\n        else {\n            htmlOut = this.options.emptyString;\n        }\n\n        self._container.innerHTML = htmlOut;\n\n        // move control to bottom row\n        // if(T('.leaflet-control-velocity').index() == 0){\n        //     T('.leaflet-control-velocity').insertAfter('.leaflet-control-mouseposition');\n        // }\n    }\n});\n\nL.Map.mergeOptions({\n    positionControl: false\n});\n\nL.Map.addInitHook(function () {\n    if (this.options.positionControl) {\n        this.positionControl = new L.Control.MousePosition();\n        this.addControl(this.positionControl);\n    }\n});\n\nL.control.velocity = function (options) {\n    return new L.Control.Velocity(options);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugins/velocity/L.Control.Velocity.js"],"sourceRoot":""}